---
title: Remote
description: Documentation on handling remote data in VectorBT PRO
icon: material/web
---

# :material-web: Remote

Data classes that subclass [RemoteData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/remote/#vectorbtpro.data.custom.remote.RemoteData) are designed
to retrieve (mainly OHLCV) data from remote sources. Unlike classes intended for locally stored data,
they communicate with remote API endpoints and must manage authentication, authorization, throttling,
and other related mechanisms. Additionally, the total amount of data to be retrieved is often unknown in advance,
and most data providers impose API rate limits and restrict the amount of data returned per request.
As a result, it is often necessary to fetch data in smaller batches and concatenate them correctly.
Fortunately, VBT provides several preset data classes that can handle all these tasks automatically.

## Arguments

Most remote data classes share the following arguments:

| Argument           | Description                                                                                                                                                                                                                                                                                                                                                       |
|--------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `client`           | Client object required to make a request. Typically, the data class provides an additional class method, `resolve_client`, to create the client based on the keyword arguments in `client_config` if the client is `None`. If a client is already provided, this step is skipped. You do not need to call `resolve_client` directly; it is handled automatically. |
| `client_config`    | Keyword arguments used to instantiate the client.                                                                                                                                                                                                                                                                                                                 |
| `start`            | Start datetime (inclusive). Will be converted to a `datetime.datetime` using [to_tzaware_datetime](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_tzaware_datetime) and may be further processed to match the format required by the data provider.                                                                                                         |
| `end`              | End datetime (exclusive). Will be converted to a `datetime.datetime` using [to_tzaware_datetime](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_tzaware_datetime) and may be further processed to match the format required by the data provider.                                                                                                           |
| `tz`               | Target timezone of the index (internally becomes `tz_convert`). If `start` and/or `end` do not have a timezone, this timezone will also be used to localize them.                                                                                                                                                                                                 |
| `timeframe`        | Timeframe provided as a human-readable string (such as `1 day`) with a multiplier (`1`) and a unit (`day`). Will be parsed into a standardized format using [split_freq_str](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.split_freq_str).                                                                                                                   |
| `limit`            | Maximum number of data items to return per request.                                                                                                                                                                                                                                                                                                               |
| `delay`            | Delay in milliseconds between requests. Helps handle API rate limits.                                                                                                                                                                                                                                                                                             | 
| `retries`          | Number of retries in case of connectivity issues or other request-specific errors. Usually only applied if the data class can collect data in batches.                                                                                                                                                                                                            |
| `show_progress`    | Whether to show the progress bar of type [ProgressBar](https://vectorbt.pro/pvt_6d1b3986/api/utils/pbar/#vectorbtpro.utils.pbar.ProgressBar). Usually only applied if the data class can collect data in batches.                                                                                                                                                                                  | 
| `pbar_kwargs`      | Keyword arguments used to configure the progress bar.                                                                                                                                                                                                                                                                                                             |
| `silence_warnings` | Whether to silence all warnings to avoid being overwhelmed with messages such as those related to timeouts.                                                                                                                                                                                                                                                       |
| `exchange`         | Exchange to fetch from, if the data class supports multiple exchanges. If so, settings can also be customized per exchange.                                                                                                                                                                                                                                       |

To view the list of arguments accepted by a remote data class fetcher, you can check the API reference,
use the Python `help` command, or use VBT's helper function
[phelp](https://vectorbt.pro/pvt_6d1b3986/api/utils/formatting/#vectorbtpro.utils.formatting.phelp)
on the class method [Data.fetch_symbol](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.fetch_symbol),
which creates a query for a single symbol and returns a Series or DataFrame:

```pycon
>>> from vectorbtpro import *

>>> vbt.phelp(vbt.CCXTData.fetch_symbol)
CCXTData.fetch_symbol(
    symbol,
    exchange=None,
    exchange_config=None,
    start=None,
    end=None,
    timeframe=None,
    tz=None,
    find_earliest_date=None,
    limit=None,
    delay=None,
    retries=None,
    fetch_params=None,
    show_progress=None,
    pbar_kwargs=None,
    silence_warnings=None,
    return_fetch_method=False
):
    Override `vectorbtpro.data.base.Data.fetch_symbol` to fetch a symbol from CCXT.
    
    Args:
        symbol (str): Symbol.
    
            Symbol can be in the `EXCHANGE:SYMBOL` format, in this case `exchange` argument will be ignored.
        exchange (str or object): Exchange identifier or an exchange object.
    
            See `CCXTData.resolve_exchange`.
        exchange_config (dict): Exchange config.
    
            See `CCXTData.resolve_exchange`.
        start (any): Start datetime.
    
            See `vectorbtpro.utils.datetime_.to_tzaware_datetime`.
        end (any): End datetime.
    
            See `vectorbtpro.utils.datetime_.to_tzaware_datetime`.
        timeframe (str): Timeframe.
    
            Allows human-readable strings such as "15 minutes".
        tz (any): Timezone.
    
            See `vectorbtpro.utils.datetime_.to_timezone`.
        find_earliest_date (bool): Whether to find the earliest date using `CCXTData.find_earliest_date`.
        limit (int): The maximum number of returned items.
        delay (float): Time to sleep after each request (in milliseconds).
    
            !!! note
                Use only if `enableRateLimit` is not set.
        retries (int): The number of retries on failure to fetch data.
        fetch_params (dict): Exchange-specific keyword arguments passed to `fetch_ohlcv`.
        show_progress (bool): Whether to show the progress bar.
        pbar_kwargs (dict): Keyword arguments passed to `vectorbtpro.utils.pbar.ProgressBar`.
        silence_warnings (bool): Whether to silence all warnings.
        return_fetch_method (bool): Required by `CCXTData.find_earliest_date`.
    
    For defaults, see `custom.ccxt` in `vectorbtpro._settings.data`.
    Global settings can be provided per exchange id using the `exchanges` dictionary.
```

As shown above, the class [CCXTData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/ccxt/#vectorbtpro.data.custom.ccxt.CCXTData) accepts
the exchange object, timeframe, start date, end date, and other keyword arguments.

!!! hint
    The class method [Data.pull](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.pull) usually accepts the
    same arguments as [Data.fetch_symbol](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.fetch_symbol).

### Settings

But why are all argument values set to `None`? Remember that `None` has a special meaning and tells
VBT to retrieve the argument's default value from the [global settings](https://vectorbt.pro/pvt_6d1b3986/api/_settings/).
Specifically, you should look at the settings defined for CCXT, which can be found in the dictionary
under `custom.ccxt` in [settings.data](https://vectorbt.pro/pvt_6d1b3986/api/_settings/#vectorbtpro._settings.data):

```pycon
>>> vbt.pprint(vbt.settings.data["custom"]["ccxt"])
Config(
    exchange='binance',
    exchange_config=dict(
        enableRateLimit=True
    ),
    start=None,
    end=None,
    timeframe='1d',
    tz='UTC',
    find_earliest_date=False,
    limit=1000,
    delay=None,
    retries=3,
    show_progress=True,
    pbar_kwargs=dict(),
    fetch_params=dict(),
    exchanges=dict(),
    silence_warnings=False
)
```

Another way to get the settings is by using the method [Data.get_settings](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.get_settings):

```pycon
>>> vbt.pprint(vbt.CCXTData.get_settings(path_id="custom"))
```

!!! hint
    Data classes register two path ids: `base` and `custom`. The `base` id manages the settings
    for the base class [Data](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data), while the `custom` id
    manages settings for any subclass of [CustomData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/custom/#vectorbtpro.data.custom.custom.CustomData).

By using the default arguments, you will pull the symbol's entire daily history from Binance.

To set a default value, you can change the config directly. For example, to change the exchange to BitMEX:

```pycon
>>> vbt.settings.data["custom"]["ccxt"]["exchange"] = "bitmex"
```

Even easier, just like you used [Data.get_settings](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.get_settings)
to get the settings dictionary, you can use [Data.set_settings](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.set_settings)
to set them:

```pycon
>>> vbt.CCXTData.set_settings(path_id="custom", exchange="bitmex")
>>> vbt.settings.data["custom"]["ccxt"]["exchange"]
'bitmex'
```

!!! note
    Overriding keys in the dictionary returned by
    [Data.get_settings](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.get_settings)
    will not have any effect.

What if you made a mistake? No need to worry! You can reset the settings at any time:

```pycon
>>> vbt.CCXTData.reset_settings(path_id="custom")
>>> vbt.settings.data["custom"]["ccxt"]["exchange"]
'binance'
```

!!! hint
    This only resets the settings for this particular class, not for all of VBT.

### Start and end

Specifying dates and times is usually very easy thanks to the built-in datetime parser
[to_tzaware_datetime](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_tzaware_datetime), which can
parse dates and times from various objects, including human-readable strings like `1 day ago`:

```pycon
>>> vbt.local_datetime("1 day ago")
datetime.datetime(2023, 8, 28, 20, 57, 49, 77715, tzinfo=tzlocal())
```

Let's illustrate this by fetching the last 10 minutes of `BTC/USDT` and `ETH/USDT`:

```pycon
>>> ccxt_data = vbt.CCXTData.pull(
...     ["BTC/USDT", "ETH/USDT"],
...     start="10 minutes ago UTC",
...     end="now UTC",
...     timeframe="1m"
... )
```

!!! note
    Different remote data classes may use different symbol notations, such as `BTC/USDT` for CCXT,
    `BTC-USD` for Yahoo Finance, `BTCUSDT` for Binance, `X:BTCUSD` for Polygon.io, and more.

[=100% "Symbol 2/2"]{: .candystripe .candystripe-animate }

```pycon
>>> ccxt_data.close
symbol                     BTC/USDT  ETH/USDT
Open time                                    
2023-08-29 18:50:00+00:00  27990.00   1738.22
2023-08-29 18:51:00+00:00  27973.54   1737.43
2023-08-29 18:52:00+00:00  27981.32   1737.53
2023-08-29 18:53:00+00:00  27964.75   1736.64
2023-08-29 18:54:00+00:00  27972.27   1737.15
2023-08-29 18:55:00+00:00  27963.03   1737.10
2023-08-29 18:56:00+00:00  27962.01   1736.70
2023-08-29 18:57:00+00:00  27970.29   1736.82
2023-08-29 18:58:00+00:00  27986.34   1737.00
2023-08-29 18:59:00+00:00  27987.54   1736.80
```

!!! hint
    Dates and times are resolved in [Data.fetch_symbol](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.fetch_symbol).
    When fetching high-frequency data, make sure to provide resolved start and end times using
    [to_tzaware_datetime](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_tzaware_datetime).
    Otherwise, by the time the first symbol is fetched, the resolved times for the next symbol may
    already be different.

### Timeframe

The timeframe format is standardized across the entire VBT codebase, including all preset data
classes. This is accomplished by the function [split_freq_str](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.split_freq_str),
which splits a timeframe string into a multiplier and a unit:

```pycon
>>> vbt.dt.split_freq_str("15 minutes")
(15, 'm')

>>> vbt.dt.split_freq_str("daily")
(1, 'D')

>>> vbt.dt.split_freq_str("1wk")
(1, 'W')

>>> vbt.dt.split_freq_str("annually")
(1, 'Y')
```

After splitting, each preset data class converts the resulting multiplier and unit into the format
accepted by its API. For example, in [PolygonData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/polygon/#vectorbtpro.data.custom.polygon.PolygonData),
the unit `"m"` is translated to `"minute"`, while in [AlpacaData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/alpaca/#vectorbtpro.data.custom.alpaca.AlpacaData)
it is translated to `TimeFrameUnit.Minute`. Note that units like `"m"` are for internal use only
and should not be used directly in Pandas. For instance, using `"m"` to construct a date offset
(for use in [pandas.DataFrame.resample](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.resample.html))
creates a month end, while using it to construct a timedelta creates a minute:

```pycon
>>> from pandas.tseries.frequencies import to_offset

>>> to_offset("1m")
<MonthEnd>

>>> pd.Timedelta("1m")
Timedelta('0 days 00:01:00')
```

In these cases, you should use [to_offset](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_offset) and
[to_timedelta](https://vectorbt.pro/pvt_6d1b3986/api/utils/datetime_/#vectorbtpro.utils.datetime_.to_timedelta) respectively,
which are in-house functions that can handle many common formats:

```pycon
>>> vbt.offset("1m")
<Minute>

>>> vbt.timedelta("1m")
Timedelta('0 days 00:01:00')
```

Let's pull 30-minute `BTC/USDT` data for the current day:

```pycon
>>> ccxt_data = vbt.CCXTData.pull(
...     "BTC/USDT",
...     start="today midnight UTC",
...     timeframe="30 minutes"
... )
>>> ccxt_data.get()
                               Open      High       Low     Close       Volume
Open time
2023-08-29 00:00:00+00:00  26120.00  26135.20  26092.91  26092.91    244.82583
2023-08-29 00:30:00+00:00  26092.92  26165.99  26084.07  26140.44    372.98168
2023-08-29 01:00:00+00:00  26140.44  26206.24  26105.78  26127.64    595.85951
...                             ...       ...       ...       ...          ...
2023-08-29 18:00:00+00:00  27892.08  27973.14  27835.84  27949.82   1217.90593
2023-08-29 18:30:00+00:00  27949.83  28020.73  27910.70  27971.79   1422.90243
2023-08-29 19:00:00+00:00  27971.78  27982.65  27900.87  27910.01    220.80118
```

### Client

Many APIs require a client to make requests. Data classes based on such APIs usually include a
class method called `resolve_client` that is used to resolve the client, which is called before
pulling each symbol. If the client is not provided by the user (`None`), this method creates
it automatically based on the `client_config`. This config can include a variety of information,
such as API keys or connection parameters. For example, here is the default client of
[BinanceData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/binance/#vectorbtpro.data.custom.binance.BinanceData):

```pycon
>>> binance_client = vbt.BinanceData.resolve_client()
>>> binance_client
<binance.client.Client at 0x7f893a193af0>
```

To provide information to this client, you can pass keyword arguments directly:

```pycon
>>> binance_client = vbt.BinanceData.resolve_client(
...     api_key="YOUR_KEY",
...     api_secret="YOUR_SECRET"
... )
>>> binance_client
<binance.client.Client at 0x7f89183512e0>
```

Since the client is created automatically, you can pass all client-related information using
the `client_config` argument during fetching:

```pycon
>>> binance_data = vbt.BinanceData.pull(
...     "BTCUSDT",
...     client_config=dict(
...         api_key="YOUR_KEY",
...         api_secret="YOUR_SECRET"
...     )
... )
>>> binance_data.get()
                               Open      High       Low     Close  \
Open time
2017-08-17 00:00:00+00:00   4261.48   4485.39   4200.74   4285.08
2017-08-18 00:00:00+00:00   4285.08   4371.52   3938.77   4108.37
2017-08-19 00:00:00+00:00   4108.37   4184.69   3850.00   4139.98
...                             ...       ...       ...       ...
2023-08-27 00:00:00+00:00  26017.38  26182.23  25966.11  26101.77
2023-08-28 00:00:00+00:00  26101.78  26253.99  25864.50  26120.00
2023-08-29 00:00:00+00:00  26120.00  28142.85  25922.00  27895.97

                                 Volume  Quote volume  Trade count  \
Open time
2017-08-17 00:00:00+00:00    795.150377  3.454770e+06         3427
2017-08-18 00:00:00+00:00   1199.888264  5.086958e+06         5233
2017-08-19 00:00:00+00:00    381.309763  1.549484e+06         2153
...                                 ...           ...          ...
2023-08-27 00:00:00+00:00  12099.642160  3.155484e+08       349090
2023-08-28 00:00:00+00:00  22692.626550  5.910089e+08       523057
2023-08-29 00:00:00+00:00  65076.334610  1.768909e+09       968856

                           Taker base volume  Taker quote volume
Open time
2017-08-17 00:00:00+00:00         616.248541        2.678216e+06
2017-08-18 00:00:00+00:00         972.868710        4.129123e+06
2017-08-19 00:00:00+00:00         274.336042        1.118002e+06
...                                      ...                 ...
2023-08-27 00:00:00+00:00        6170.486640        1.609182e+08
2023-08-28 00:00:00+00:00       10912.405490        2.842262e+08
2023-08-29 00:00:00+00:00       33459.465920        9.098352e+08

[2204 rows x 9 columns]
```

However, if you run [BinanceData.resolve_client](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/binance/#vectorbtpro.data.custom.binance.BinanceData.resolve_client),
you will notice that it takes time to instantiate a client, and you probably do not want to wait that
long for every single symbol you are trying to fetch. A better approach is to instantiate a client
manually just once and then pass it via the `client` argument, which will reuse the client and
make fetching much faster:

```pycon
>>> binance_data = vbt.BinanceData.pull(
...     "BTCUSDT",
...     client=binance_client
... )
```

!!! info
    This also enables reusing the client or client config during updating since any argument passed to
    the fetcher is stored inside the dictionary
    [Data.fetch_kwargs](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.fetch_kwargs),
    which is used by the updater.

!!! warning
    However, this also means that sharing the data object with anyone may expose your credentials!

To maintain security, the recommended approach is to set any credentials and clients globally, as
previously discussed. This way, they will not be stored inside the data instance.

```pycon
>>> vbt.BinanceData.set_settings(
...     path_id="custom",
...     client=binance_client
... )
```

!!! hint
    See the API documentation of the specific data class for more examples.

### Saving

To save any remote data instance, see [this documentation](https://vectorbt.pro/pvt_6d1b3986/documentation/data/local/). In short,
pickling is preferred because it also saves all arguments that were passed to the fetcher,
such as the selected timeframe. These arguments are important when updating because without them,
you would need to provide them manually each time you attempt to update the data.

```pycon
>>> binance_data = vbt.BinanceData.pull(
...     "BTCUSDT",
...     start="today midnight UTC",
...     timeframe="1 hour"
... )
>>> binance_data.save("binance_data")

>>> binance_data = vbt.BinanceData.load("binance_data")
>>> vbt.pprint(binance_data.fetch_kwargs)
symbol_dict(
    BTCUSDT=dict(
        start='today midnight UTC',
        timeframe='1 hour',
        silence_warnings=False
    )
)
```

As you can see, all arguments were saved along with the data instance. But if you do not plan on
updating the data, you can save the arrays themselves to one or multiple CSV files or HDF keys,
one per symbol:

```pycon
>>> binance_data.to_csv()  # (1)!

>>> csv_data = vbt.CSVData.pull("BTCUSDT.csv")
```

1. The data will be saved into a CSV file named `{symbol}.csv`.

But what if you want to update the data stored locally in a CSV or HDF file?
The fetching-related keyword arguments no longer include the timeframe or other parameters.
They only include arguments important for the data class holding the data—
[CSVData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/csv/#vectorbtpro.data.custom.csv.CSVData):

```pycon
>>> vbt.pprint(csv_data.fetch_kwargs)
symbol_dict(
    BTCUSDT=dict(
        path=PosixPath('BTCUSDT.csv')
    )
)
```

If you use the update method on this data instance, it will try to update using the local data,
not remote data. To update from a remote endpoint, you need to switch the data class
back to the original class—[BinanceData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/binance/#vectorbtpro.data.custom.binance.BinanceData)
in this case. For this, you can use the method [Data.switch_class](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.switch_class),
which can also clear all the fetching-related and returned keyword arguments that are
related to the CSV file:

```pycon
>>> binance_data = csv_data.switch_class(
...     new_cls=vbt.BinanceData,
...     clear_fetch_kwargs=True,
...     clear_returned_kwargs=True
... )
>>> type(binance_data)
vectorbtpro.data.custom.binance.BinanceData
```

Next, use the method [Data.update_fetch_kwargs](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data.update_fetch_kwargs)
to update the fetching keyword arguments with the timeframe to avoid setting it again whenever
you update:

```pycon
>>> binance_data = binance_data.update_fetch_kwargs(timeframe="1 hour")
>>> vbt.pprint(binance_data.fetch_kwargs)
symbol_dict(
    BTCUSDT=dict(
        timeframe='1 hour'
    )
)
```

Is there an easier way? Absolutely! The class methods
[RemoteData.from_csv](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/remote/#vectorbtpro.data.custom.remote.RemoteData.from_csv)
and [RemoteData.from_hdf](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/hdf/#vectorbtpro.data.custom.hdf.RemoteData.from_hdf)
are available from all data classes and automatically perform all the steps above:

```pycon
>>> binance_data = vbt.BinanceData.from_csv(
...     "BTCUSDT.csv",
...     fetch_kwargs=dict(timeframe="1 hour")
... )

>>> type(binance_data)
<class 'vectorbtpro.data.custom.binance.BinanceData'>

>>> vbt.pprint(binance_data.fetch_kwargs)
symbol_dict(
    BTCUSDT=dict(
        timeframe='1 hour'
    )
)
```

### Updating

Updating a data instance is generally straightforward:

```pycon
>>> binance_data = binance_data.update()
```

!!! note
    Updating the current data instance always returns a new data instance.

Under the hood, the updater first overrides the start date with the latest date in the index,
and then calls the fetcher. This lets you specify or override any argument that was originally used
when fetching. Also note that it will only pull new data if the end date is not fixed. If you used
the end date `2022-01-01` when fetching, it will be used again when updating. Be sure to set
`end` to `"now"` or `"now UTC"` if you want to get fresh data. Let's first fetch the history
for the year 2020, and then append the history for the year 2021:

```pycon
>>> binance_data = vbt.BinanceData.pull(
...     "BTCUSDT",
...     start="2020-01-01",
...     end="2021-01-01"
... )
>>> binance_data = binance_data.update(end="2022-01-01")  # (1)!
>>> binance_data.wrapper.index
DatetimeIndex(['2020-01-01 00:00:00+00:00', '2020-01-02 00:00:00+00:00',
               '2020-01-03 00:00:00+00:00', '2020-01-04 00:00:00+00:00',
               '2020-01-05 00:00:00+00:00', '2020-01-06 00:00:00+00:00',
               ...
               '2021-12-26 00:00:00+00:00', '2021-12-27 00:00:00+00:00',
               '2021-12-28 00:00:00+00:00', '2021-12-29 00:00:00+00:00',
               '2021-12-30 00:00:00+00:00', '2021-12-31 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', name='Open time', length=731, freq='D')
```

1. Without overriding, the argument `end` will default to the value passed to the fetcher—`2021-01-01`.

## From URL

Although [CSVData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/csv/#vectorbtpro.data.custom.csv.CSVData) is designed for local file systems,
you can use a few tricks to pull remote data with it as well! Remember that it uses
[pandas.read_csv](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html)?
This function has a `filepath_or_buffer` argument, which can accept a URL.
To use this feature, simply disable the path matching mechanism by setting `match_paths` to False.

Here is an example of pulling S&P 500 index data:

```pycon
>>> url = "https://datahub.io/core/s-and-p-500/r/data.csv"
>>> csv_data = vbt.CSVData.pull(url, match_paths=False)
>>> csv_data.get()
                             SP500  Dividend  Earnings  Consumer Price Index  \
Date                                                                           
1871-01-01 00:00:00+00:00     4.44      0.26      0.40                 12.46   
1871-02-01 00:00:00+00:00     4.50      0.26      0.40                 12.84   
1871-03-01 00:00:00+00:00     4.61      0.26      0.40                 13.03   
...                            ...       ...       ...                   ...   
2018-02-01 00:00:00+00:00  2705.16     49.64       NaN                248.99   
2018-03-01 00:00:00+00:00  2702.77     50.00       NaN                249.55   
2018-04-01 00:00:00+00:00  2642.19       NaN       NaN                249.84   

                           Long Interest Rate  Real Price  Real Dividend  \
Date                                                                       
1871-01-01 00:00:00+00:00                5.32       89.00           5.21   
1871-02-01 00:00:00+00:00                5.32       87.53           5.06   
1871-03-01 00:00:00+00:00                5.33       88.36           4.98   
...                                       ...         ...            ...   
2018-02-01 00:00:00+00:00                2.86     2714.34          49.81   
2018-03-01 00:00:00+00:00                2.84     2705.82          50.06   
2018-04-01 00:00:00+00:00                2.80     2642.19            NaN   

                           Real Earnings   PE10  
Date                                             
1871-01-01 00:00:00+00:00           8.02    NaN  
1871-02-01 00:00:00+00:00           7.78    NaN  
1871-03-01 00:00:00+00:00           7.67    NaN  
...                                  ...    ...  
2018-02-01 00:00:00+00:00            NaN  32.12  
2018-03-01 00:00:00+00:00            NaN  31.99  
2018-04-01 00:00:00+00:00            NaN  31.19  

[1768 rows x 9 columns]
```

### AWS S3

Here is another example for AWS S3:

```pycon
>>> import boto3
>>> s3_client = boto3.client("s3")  # (1)!

>>> symbols = ["BTCUSDT", "ETHUSDT"]
>>> paths = vbt.symbol_dict({ 
...     s: s3_client.get_object(
...         Bucket="binance", 
...         Key=f"data/{s}.csv")["Body"]  # (2)!
...     for s in symbols
... })
>>> s3_data = vbt.CSVData.pull(symbols, paths=paths, match_paths=False)  # (3)!
>>> s3_data.close
symbol                      BTCUSDT  ETHUSDT
Open time                                   
2017-08-17 00:00:00+00:00   4285.08   302.00
2017-08-18 00:00:00+00:00   4108.37   293.96
2017-08-19 00:00:00+00:00   4139.98   290.91
2017-08-20 00:00:00+00:00   4086.29   299.10
2017-08-21 00:00:00+00:00   4016.00   323.29
...                             ...      ...
2022-02-14 00:00:00+00:00  42535.94  2929.75
2022-02-15 00:00:00+00:00  44544.86  3183.52
2022-02-16 00:00:00+00:00  43873.56  3122.30
2022-02-17 00:00:00+00:00  40515.70  2891.87
2022-02-18 00:00:00+00:00  39892.83  2768.74

[1647 rows x 2 columns]
```

1. See [Python, Boto3, and AWS S3: Demystified](https://realpython.com/python-boto3-aws-s3/).
2. Adapt the code to your specific bucket and keys.
3. Each path in `paths` will become `filepath_or_buffer`.

You could load both datasets using [pandas.read_csv](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html)
directly, but wrapping them with [CSVData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/csv/#vectorbtpro.data.custom.csv.CSVData) lets you
take advantage of the powerful [Data](https://vectorbt.pro/pvt_6d1b3986/api/data/base/#vectorbtpro.data.base.Data) class in VBT.
For example, you can update your remote datasets whenever new data points arrive, which is a real :gem:

[:material-language-python: Python code](https://vectorbt.pro/pvt_6d1b3986/assets/jupytext/documentation/data/remote.py.txt){ .md-button target="blank_" }