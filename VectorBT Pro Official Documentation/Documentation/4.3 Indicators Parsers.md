---
title: Parsers
description: Documentation on parsing indicators in VectorBT PRO
icon: material/code-tags
---

# :material-code-tags: Parsers

[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory)
uses a set of parsers to simplify the process of creating indicators. These include parsers for
third-party indicators as well as an advanced expression parser.

!!! info
    Each parser method is a class method with the prefix `from_`, so you do not need to
    create or pass any information to the indicator factory using `vbt.IF(...)` -
    the method handles this for you!

## TA-Lib

[IndicatorFactory.from_talib](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_talib)
can parse [TA-Lib](https://github.com/mrjbq7/ta-lib) indicators. When you provide the name of an indicator,
the method retrieves the TA-Lib abstract function and then checks the `info` dictionary to determine the
input, parameter, and output names. After creating a factory instance, it builds an apply function that can
run the indicator function on two-dimensional inputs, instead of only the one-dimensional inputs that TA-Lib
supports by default.

To view the list of all supported indicators:

```pycon
>>> from vectorbtpro import *

>>> vbt.IF.list_talib_indicators()  # (1)!
{'ACOS',
 'AD',
 'ADD',
 ...
 'WCLPRICE',
 'WILLR',
 'WMA'}
```

1. Uses [IndicatorFactory.list_talib_indicators](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.list_talib_indicators).

To retrieve an indicator:

```pycon
>>> vbt.IF.from_talib('RSI')  # (1)!
vectorbtpro.indicators.factory.talib.RSI
```

1. Uses [IndicatorFactory.from_talib](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_talib).

Or, you can use a shortcut:

```pycon
>>> vbt.talib('RSI')
vectorbtpro.indicators.factory.talib.RSI
```

### Skipping NaN

TA-Lib indicators often do not handle missing data well. For example, a single NaN in a time series can
cause all subsequent values to become NaN:

```pycon
>>> price = vbt.RandomData.pull(
...     start='2020-01-01', 
...     end='2020-06-01', 
...     timeframe='1H',
...     seed=42
... ).get()
>>> price_na = price.copy()
>>> price_na.iloc[2] = np.nan  # (1)!

>>> SMA = vbt.talib("SMA")
>>> sma = SMA.run(price_na, timeperiod=10)
>>> sma.real
2019-12-31 22:00:00+00:00   NaN
2019-12-31 23:00:00+00:00   NaN
2020-01-01 00:00:00+00:00   NaN
2020-01-01 01:00:00+00:00   NaN
2020-01-01 02:00:00+00:00   NaN
...                         ...
2020-05-31 18:00:00+00:00   NaN
2020-05-31 19:00:00+00:00   NaN
2020-05-31 20:00:00+00:00   NaN
2020-05-31 21:00:00+00:00   NaN
2020-05-31 22:00:00+00:00   NaN
Freq: H, Name: 10, Length: 3649, dtype: float64
```

1. Make a single value missing.

To address this, you can instruct the indicator factory to run the indicator only on non-NA values,
then insert the output values at their original positions:

```pycon
>>> sma = SMA.run(price_na, timeperiod=10, skipna=True)
>>> sma.real
2019-12-31 22:00:00+00:00           NaN
2019-12-31 23:00:00+00:00           NaN
2020-01-01 00:00:00+00:00           NaN
2020-01-01 01:00:00+00:00           NaN
2020-01-01 02:00:00+00:00           NaN
...                                 ...
2020-05-31 18:00:00+00:00    213.169260
2020-05-31 19:00:00+00:00    212.477181
2020-05-31 20:00:00+00:00    211.911416
2020-05-31 21:00:00+00:00    211.310849
2020-05-31 22:00:00+00:00    210.899923
Freq: H, Name: 10, Length: 3649, dtype: float64
```

!!! hint
    Another method is to forward fill NaN values before running an indicator, but this can distort the
    results. Only use this approach when it is truly appropriate.

### Resampling

Another feature provided by the indicator factory is support for parameterized time frames.

Here is how it works:

1. The wrapper downsamples input arrays to the target time frame.
2. It runs the indicator on the downsampled input arrays.
3. Output arrays are then upsampled back to the original time frame.

This allows you to pack multiple time frames into a single two-dimensional array:

```pycon
>>> sma = SMA.run(
...     price_na, 
...     timeperiod=10, 
...     skipna=True, 
...     timeframe=["1h", "4h", "1d"]
... )
>>> sma.real
sma_timeperiod                                             10
sma_timeframe                      1h          4h          1d
2019-12-31 22:00:00+00:00         NaN         NaN         NaN
2019-12-31 23:00:00+00:00         NaN         NaN         NaN
2020-01-01 00:00:00+00:00         NaN         NaN         NaN
2020-01-01 01:00:00+00:00         NaN         NaN         NaN
2020-01-01 02:00:00+00:00         NaN         NaN         NaN
...                               ...         ...         ...
2020-05-31 18:00:00+00:00  213.169260  215.561805  206.104351
2020-05-31 19:00:00+00:00  212.477181  214.422456  206.104351
2020-05-31 20:00:00+00:00  211.911416  214.422456  206.104351
2020-05-31 21:00:00+00:00  211.310849  214.422456  206.104351
2020-05-31 22:00:00+00:00  210.899923  214.422456  206.104351

[3649 rows x 3 columns]
```

!!! note
    If some timestamps are missing, VBT may have trouble parsing the source index frequency.
    To specify the frequency directly, pass
    `broadcast_kwargs=dict(wrapper_kwargs=dict(freq="1h"))`, for example.
    Without the source frequency, VBT will upsample the downsampled arrays between each pair
    of timestamps in the source index, rather than relying on its frequency, which might be
    undesirable.

### Plotting

You can also plot each indicator. This is done programmatically by parsing the output flags of the
indicator. For example, here is how to use `STOCH`:

```pycon
>>> STOCH = vbt.talib('STOCH')
>>> STOCH.output_flags
OrderedDict([('slowk', ['Dashed Line']), ('slowd', ['Dashed Line'])])

>>> ohlc = price.resample('1d').ohlc()
>>> stoch = STOCH.run(ohlc['high'], ohlc['low'], ohlc['close'])
>>> stoch.plot().show()
```

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/stoch.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/stoch.dark.svg#only-dark){: .iimg loading=lazy }

To see the arguments that the `plot` function accepts, use [phelp](https://vectorbt.pro/pvt_6d1b3986/api/utils/formatting/#vectorbtpro.utils.formatting.phelp):

```pycon
>>> vbt.phelp(STOCH.plot)
plot(
    self,
    column=None,
    limits=None,
    add_shape_kwargs=None,
    add_trace_kwargs=None,
    fig=None,
    slowk_trace_kwargs=None,
    slowd_trace_kwargs=None,
    **layout_kwargs
):
    Plot the outputs of the indicator based on their flags.
            
    Args:
        column (str): Name of the column to plot.
        limits (tuple of float): Tuple of the lower and upper limit.
        add_shape_kwargs (dict): Keyword arguments passed to `fig.add_shape` when adding the range between both limits.
        add_trace_kwargs (dict): Keyword arguments passed to `fig.add_trace` when adding each trace.
        slowk_trace_kwargs (dict): Keyword arguments passed to the trace of `slowk`.
        slowd_trace_kwargs (dict): Keyword arguments passed to the trace of `slowd`.
        fig (Figure or FigureWidget): Figure to add the traces to.
        **layout_kwargs: Keyword arguments passed to `fig.update_layout`.
```

Now, let's create a plot with two subplots: OHLC above, and %D and %K below. We will also change
the style of both output lines from dashed to solid and display a range between an oversold limit
of 20 and an overbought limit of 80:

```pycon
>>> fig = vbt.make_subplots(
...     rows=2, 
...     cols=1, 
...     shared_xaxes=True,  # (1)!
...     vertical_spacing=0.05)
>>> ohlc.vbt.ohlcv.plot(
...     add_trace_kwargs=dict(row=1, col=1),  # (2)!
...     fig=fig,
...     xaxis=dict(rangeslider_visible=False))  # (3)!
>>> stoch.plot(
...     limits=(20, 80),
...     add_trace_kwargs=dict(row=2, col=1),  # (4)!
...     slowk_trace_kwargs=dict(line=dict(dash=None)),  # (5)!
...     slowd_trace_kwargs=dict(line=dict(dash=None)),
...     fig=fig)
>>> fig.show()
```

1. All time series use the same index.
2. First subplot.
3. Passed directly to `fig.update_layout`.
4. Second subplot.
5. Passed directly to `fig.add_trace`.

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/stoch_subplots.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/stoch_subplots.dark.svg#only-dark){: .iimg loading=lazy }

## Pandas TA

[IndicatorFactory.from_pandas_ta](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_pandas_ta)
can parse [Pandas TA](https://github.com/twopirllc/pandas-ta) indicators. Since Pandas TA indicators do not
have metadata attached to each indicator, a method called
[IndicatorFactory.parse_pandas_ta_config](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.parse_pandas_ta_config)
is used. This method reads the signature of an indicator function to determine the input and parameter
names and their default values. It also passes several dozen rows of sample data to the function to
identify the number and names of the outputs.

!!! note
    If any indicator raises an error while parsing, try increasing the number of rows passed to the
    indicator function. For example, use `parse_kwargs=dict(test_index_len=150)`.

To get the list of all supported indicators:

```pycon
>>> vbt.IF.list_pandas_ta_indicators()  # (1)!
{'ABERRATION',
 'ACCBANDS',
 'AD',
 ...
 'XSIGNALS',
 'ZLMA',
 'ZSCORE'}
```

1. Using [IndicatorFactory.list_pandas_ta_indicators](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.list_pandas_ta_indicators).

To get an indicator:

```pycon
>>> vbt.IF.from_pandas_ta('RSI')  # (1)!
vectorbtpro.indicators.factory.pandas_ta.RSI
```

1. Using [IndicatorFactory.from_pandas_ta](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_pandas_ta).

Or, use the shortcut:

```pycon
>>> vbt.pandas_ta('RSI')
vectorbtpro.indicators.factory.pandas_ta.RSI
```

## TA

[IndicatorFactory.from_ta](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_ta)
can parse [TA](https://github.com/bukosabino/ta) indicators. Similar to Pandas TA, TA indicators must be
explicitly parsed to obtain the context of each indicator function. Since every indicator is a class,
there is a method called [IndicatorFactory.parse_ta_config](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.parse_ta_config)
that reads the signature, docstring, and attributes of the class to determine the input, parameter,
and output names, as well as their defaults.

To get the list of all supported indicators:

```pycon
>>> vbt.IF.list_ta_indicators()  # (1)!
{'ADXIndicator',
 'AccDistIndexIndicator',
 'AroonIndicator',
 ...
 'VortexIndicator',
 'WMAIndicator',
 'WilliamsRIndicator'
```

1. Using [IndicatorFactory.list_ta_indicators](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.list_ta_indicators).

To get an indicator:

```pycon
>>> vbt.IF.from_ta('RSIIndicator')  # (1)!
vectorbtpro.indicators.factory.ta.RSIIndicator
```

1. Using [IndicatorFactory.from_ta](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_ta).

Or, use the shortcut:

```pycon
>>> vbt.ta('RSIIndicator')
vectorbtpro.indicators.factory.ta.RSIIndicator
```

## Expressions

Expressions are a brand-new way to define indicators of any complexity using regular strings.
The main advantage of expressions over custom and apply functions is that VBT can easily
introspect the code of an indicator and add many useful automations.

Expressions are converted into full-featured indicators by a hybrid method,
[IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr).
Why hybrid? It is both a class method and an instance method. You can call this method on an instance
if you want full control over the indicator's specification, or on a class if you want the entire
specification to be parsed for you. Let's try both approaches while building an ATR indicator!

### Instance method

Here is a semi-automated implementation using the instance method:

```pycon
>>> expr = """
... tr0 = abs(high - low)
... tr1 = abs(high - fshift(close))
... tr2 = abs(low - fshift(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, n)
... tr, atr
... """
>>> ATR = vbt.IF(
...     class_name='ATR',
...     input_names=['high', 'low', 'close'],
...     param_names=['n'],
...     output_names=['tr', 'atr']
... ).from_expr(expr, n=14)

>>> atr = ATR.run(ohlc['high'], ohlc['low'], ohlc['close'])
>>> atr.atr
2019-12-31 00:00:00+00:00          NaN
2020-01-01 00:00:00+00:00          NaN
2020-01-02 00:00:00+00:00          NaN
2020-01-03 00:00:00+00:00          NaN
2020-01-04 00:00:00+00:00          NaN
...                                ...
2020-05-27 00:00:00+00:00    13.394434
2020-05-28 00:00:00+00:00    13.338482
2020-05-29 00:00:00+00:00    13.480809
2020-05-30 00:00:00+00:00    13.003231
2020-05-31 00:00:00+00:00    12.888624
Freq: D, Length: 153, dtype: float64
```

The expression `expr` is regular Python code without extensions that is evaluated using Python's `eval`
command. All function names are resolved by the parser before evaluation.

### Class method

Here is a fully-automated implementation using the class method and annotations:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(@in_high - @in_low)
... tr1 = abs(@in_high - fshift(@in_close))
... tr2 = abs(@in_low - fshift(@in_close))
... @out_tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... @out_atr = wwm_mean_1d(@out_tr, @p_n)
... @out_tr, @out_atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14)
```

In the first example, we provided all the required information manually by constructing
a new instance of [IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory).
The parser identified each input and parameter name in the expression and replaced them with actual arrays.
In the second example, we used annotations to give the parser hints about the meaning of each variable.
Whenever the parser finds a substring starting with `@`, it knows the variable has a special meaning
for constructing a factory instance. The prefixes `@_in`, `@_p`, and `@_out` indicate an input,
parameter, and output, respectively. The names appear in the order they appear in the expression
(apart from OHLCV, where H always comes after O):

```pycon
>>> ATR.input_names
('high', 'low', 'close')
```

The parser can also detect information not starting with a special character.
For example, inputs such as `open`, `high`, `low`, `close`, and `volume` are recognized automatically,
so there is no need to annotate them. These are called magnet inputs, and you can specify them via the
`magnet_inputs` argument. If no outputs use annotations and the expression is a multiline string with
the last line containing a tuple of valid variable names, you do not need to annotate the outputs either.
Also, as shown above, you can provide the class name on the first line, followed by a colon:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - fshift(close))
... tr2 = abs(low - fshift(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, @p_n)
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14)
>>> ATR.input_names
('high', 'low', 'close')

>>> ATR.output_names
('tr', 'atr')
```

What about functions? The parser identifies functions by searching various modules and packages.
In this example, `abs` and `nanmax` are from NumPy, while `wwm_mean_1d` is found among generic
Numba-compiled functions in [nb](https://vectorbt.pro/pvt_6d1b3986/api/generic/nb/) (even without the `_nb` suffix).
See the API for [IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr)
for full details. To avoid naming conflicts, you can explicitly access the NumPy, Pandas, and VBT
modules as `np`, `pd`, and `vbt`:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - vbt.nb.fshift_nb(close))
... tr2 = abs(low - vbt.nb.fshift_nb(close))
... tr = np.nanmax(np.column_stack((tr0, tr1, tr2)), axis=1)
... atr = vbt.nb.wwm_mean_1d_nb(tr, n)
... tr, atr
... """
```

### TA-Lib

Another automation covers TA-Lib indicators: VBT will replace any variable annotated
with `@talib` with an actual TA-Lib indicator function that can operate on both one-dimensional and
two-dimensional data!

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - fshift(close))
... tr2 = abs(low - fshift(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = @talib_ema(tr, 2 * n - 1)  # Wilder's EMA
... tr, atr
... """
```

### Context

How can you define your own functions and rules? Any additional keyword argument passed to
[IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr)
acts as a context for evaluation and can replace a variable with the same name. Let's define our
own function `shift_close`, which is an alias for [fshift_nb](https://vectorbt.pro/pvt_6d1b3986/api/generic/nb/base/#vectorbtpro.generic.nb.base.fshift_nb):

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - shift_close(close))
... tr2 = abs(low - shift_close(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, @p_n)
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14, shift_close=vbt.nb.fshift_nb)
```

You can also create functions that depend on the evaluation context. In the example above,
you can have `shift_close` accept the context and retrieve the number of periods to shift the closing price
(just as an example):

```pycon
>>> def shift_close(close, context):
...     return vbt.nb.fshift_nb(close, context.get('shift', 1))

>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - shift_close(close))
... tr2 = abs(low - shift_close(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, @p_n)
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14, shift_close=shift_close, shift=2)
```

The context will be automatically passed to the function once `context` has been recognized in its
arguments. Moreover, you can also make `shift_close` retrieve the closing price itself.
Notice how `shift_close` takes no arguments in the expression:

```pycon
>>> def shift_close(context):
...     return vbt.nb.fshift_nb(context['close'], context.get('shift', 1))

>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - shift_close())
... tr2 = abs(low - shift_close())
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, @p_n)
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14, shift_close=shift_close)
```

If you run this, you will receive an error indicating that `close` was not found in the context. This happens
because the input `close` is not "visible" in the expression, so it was not added to the list of input names.
To make any input, in-place output, or parameter visible—even if it is not included directly in the expression—you
must notify VBT that a function depends on it. You do this using a dictionary called
`func_mapping`, which maps functions to the magnet names they depend on:

```pycon
>>> func_mapping = dict(
...     shift_close=dict(
...         func=shift_close,
...         magnet_inputs=['close']
...     )
... )
>>> ATR = vbt.IF.from_expr(expr, n=14, func_mapping=func_mapping)
```

Since `shift_close` depends only on the context, you can instruct the parser to call it
before evaluation and only once, effectively caching its result. To do this, use
`res_func_mapping` instead of `func_mapping`:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - shifted_close)
... tr2 = abs(low - shifted_close)
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, @p_n)
... tr, atr
... """
>>> res_func_mapping = dict(
...     shifted_close=dict(
...         func=shift_close,
...         magnet_inputs=['close']
...     )
... )
>>> ATR = vbt.IF.from_expr(expr, n=14, res_func_mapping=res_func_mapping)
```

Notice that `shifted_close` no longer has parentheses—it is now an array.

### Settings

But that's not all. What if you want to override any information passed to
[IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr)
from within the expression itself? You can! Define a dictionary anywhere in the expression and annotate
it with `@settings({...})`. The dictionary inside the parentheses will be evaluated with Python's `eval`
function before the main evaluation and will be merged over the default settings of the factory method.

Let's rewrite the [instance method](#instance-method) example using only an expression:

```pycon
>>> expr = """
... @settings(dict(
...     factory_kwargs=dict(
...         class_name='ATR',
...         input_names=['high', 'low', 'close'],
...         param_names=['n'],
...         output_names=['tr', 'atr']
...     ),
...     n=14
... ))
...
... tr0 = abs(high - low)
... tr1 = abs(high - fshift(close))
... tr2 = abs(low - fshift(close))
... tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... atr = wwm_mean_1d(tr, n)
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr)
```

### Stacking

Remember, you can use any Python code in your expressions—even other indicators.
To make using indicators easier, there is a convenient annotation `@res`, which takes
the name of an indicator and creates an automatically resolved function from it, similar to
`shifted_close` above. This function becomes an entry in `res_func_mapping`, and the indicator's
input, in-place output, and parameter names are added to the entry's magnet lists. This means you do not
need to worry about passing the correct information to the indicator—vectorbt handles it for you!

Let's illustrate this by defining basic SuperTrend bands:

```pycon
>>> expr = """
... SuperTrend[st]:
... avg_price = (high + low) / 2
... up = avg_price + @p_mult * @res_talib_atr
... down = avg_price - @p_mult * @res_talib_atr
... up, down
... """  # (1)!
>>> SuperTrend = vbt.IF.from_expr(expr, mult=3, atr_timeperiod=10)

>>> SuperTrend.input_names  # (2)!
('high', 'low', 'close')

>>> SuperTrend.param_names  # (3)!
('mult', 'atr_timeperiod')

>>> SuperTrend.output_names
('up', 'down')

>>> st = SuperTrend.run(ohlc['high'], ohlc['low'], ohlc['close'])
>>> st.up
2019-12-31 00:00:00+00:00           NaN
2020-01-01 00:00:00+00:00           NaN
2020-01-02 00:00:00+00:00           NaN
2020-01-03 00:00:00+00:00           NaN
2020-01-04 00:00:00+00:00           NaN
...                                 ...
2020-05-27 00:00:00+00:00    240.698333
2020-05-28 00:00:00+00:00    245.683118
2020-05-29 00:00:00+00:00    251.211675
2020-05-30 00:00:00+00:00    256.406868
2020-05-31 00:00:00+00:00    250.201819
Freq: D, Length: 153, dtype: float64
```

1. A short name for the indicator can be provided in square brackets following the class name.
2. The TA-Lib ATR indicator depends on `high`, `low`, and `close`.
3. Our indicator depends on the multiplier `mult`, while ATR also depends on `timeperiod`.

What happens if two indicators have overlapping inputs, parameters, or other arguments?
Every argument except for the inputs receives a prefix with the indicator's short name
([IndicatorBase.short_name](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.short_name)).
Under the hood, VBT checks the signature of the indicator's `run` method to see
whether there is an argument with the same name in the context (and remember the prefix).

By default, the resolved function returns raw output as one or more NumPy arrays.
If the indicator has more than one output, you can use regular indexing to select a specific array,
such as `@res_talib_macd[0]`. Let's disable raw outputs for ATR and access the `real` Pandas object
from its indicator instance instead:

```pycon
>>> expr = """
... SuperTrend[st]:
... avg_price = (high + low) / 2
... up = avg_price + @p_mult * @res_talib_atr.real.values
... down = avg_price - @p_mult * @res_talib_atr.real.values
... up, down
... """
>>> SuperTrend = vbt.IF.from_expr(
...     expr,
...     mult=3,
...     atr_timeperiod=10,
...     atr_kwargs=dict(return_raw=False))  # (1)!
```

1. If you run `vbt.phelp(vbt.talib('ATR').run)`, you will see that additional keyword arguments
are passed as `**kwargs`, so you can specify `atr_kwargs` to target those variable arguments.

### One-liners

There is nothing more satisfying than defining an indicator in one line :drooling_face:

```pycon
>>> AvgPrice = vbt.IF.from_expr("AvgPrice: @out_avg_price:(high + low) / 2")

>>> AvgPrice.run(ohlc['high'], ohlc['low']).avg_price
2019-12-31 00:00:00+00:00    100.496714
2020-01-01 00:00:00+00:00    100.216791
2020-01-02 00:00:00+00:00     92.735610
2020-01-03 00:00:00+00:00     90.353978
2020-01-04 00:00:00+00:00     91.676538
...                                 ...
2020-05-27 00:00:00+00:00    200.426358
2020-05-28 00:00:00+00:00    205.655007
2020-05-29 00:00:00+00:00    210.587055
2020-05-30 00:00:00+00:00    217.806298
2020-05-31 00:00:00+00:00    212.041686
Freq: D, Length: 153, dtype: float64
```

Notice how the output annotation `@out` is no longer bound to any variable and is now written similarly
to the class name, with a trailing colon followed by the output expression.
If there are multiple outputs, separate their output expressions with a comma.
Here is a single-line expression for basic SuperTrend bands with multiple outputs:

```pycon
>>> SuperTrend = vbt.IF.from_expr(
...     "SuperTrend[st]: @out_up:@res_avg_price + @p_mult * @res_talib_atr, "
...     "@out_down:@res_avg_price - @p_mult * @res_talib_atr",  # (1)!
...     avg_price=AvgPrice,
...     atr_timeperiod=10, 
...     mult=3)
>>> st = SuperTrend.run(ohlc['high'], ohlc['low'], ohlc['close'])

>>> fig = ohlc.vbt.ohlcv.plot()
>>> st.up.rename('Upper').vbt.plot(fig=fig)
>>> st.down.rename('Lower').vbt.plot(fig=fig)
>>> fig.show()
```

1. Split the expression for better readability.

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/supertrend.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/supertrend.dark.svg#only-dark){: .iimg loading=lazy }

### Using Pandas

Like many other factory methods, [IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr)
passes inputs and in-place outputs as two-dimensional NumPy arrays. You can enable the `keep_pd` flag to work
with Pandas objects. Let's run our ATR indicator using only Pandas:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(high - low)
... tr1 = abs(high - close.shift())
... tr2 = abs(low - close.shift())
... tr = pd.concat((tr0, tr1, tr2), axis=1).max(axis=1)
... atr = tr.ewm(alpha=1 / @p_n, adjust=False, min_periods=@p_n).mean()
... tr, atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14, keep_pd=True)
>>> atr = ATR.run(ohlc['high'], ohlc['low'], ohlc['close'])
>>> atr.atr
2019-12-31 00:00:00+00:00          NaN
2020-01-01 00:00:00+00:00          NaN
2020-01-02 00:00:00+00:00          NaN
2020-01-03 00:00:00+00:00          NaN
2020-01-04 00:00:00+00:00          NaN
                               ...    
2020-05-27 00:00:00+00:00    13.394434
2020-05-28 00:00:00+00:00    13.338482
2020-05-29 00:00:00+00:00    13.480809
2020-05-30 00:00:00+00:00    13.003231
2020-05-31 00:00:00+00:00    12.888624
Freq: D, Length: 153, dtype: float64
```

!!! note
    Unlike the previous NumPy-only expressions, this expression will not work for
    multiple columns of input data.

For simpler expressions, you can instruct the parser to use
[pandas.eval](https://pandas.pydata.org/docs/reference/api/pandas.eval.html) instead of Python's `eval`.
This provides multi-threading and other performance benefits for large inputs, since `pd.eval`
switches to [NumExpr](https://github.com/pydata/numexpr) by default:

```pycon
>>> AvgPrice = vbt.IF.from_expr(
...     "AvgPrice: @out_avg_price:(high + low) / 2",
...     use_pd_eval=True
... )

>>> AvgPrice.run(ohlc['high'], ohlc['low']).avg_price
2019-12-31 00:00:00+00:00    100.496714
2020-01-01 00:00:00+00:00    100.216791
2020-01-02 00:00:00+00:00     92.735610
2020-01-03 00:00:00+00:00     90.353978
2020-01-04 00:00:00+00:00     91.676538
                                ...    
2020-05-27 00:00:00+00:00    200.426358
2020-05-28 00:00:00+00:00    205.655007
2020-05-29 00:00:00+00:00    210.587055
2020-05-30 00:00:00+00:00    217.806298
2020-05-31 00:00:00+00:00    212.041686
Freq: D, Length: 153, dtype: float64
```

### Debugging

To view the expression after parsing all annotations, set `return_clean_expr` to True:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(@in_high - @in_low)
... tr1 = abs(@in_high - fshift(@in_close))
... tr2 = abs(@in_low - fshift(@in_close))
... @out_tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... @out_atr = wwm_mean_1d(@out_tr, @p_n)
... @out_tr, @out_atr
... """
>>> print(vbt.IF.from_expr(expr, n=14, return_clean_expr=True))
tr0 = abs(__in_high - __in_low)
tr1 = abs(__in_high - fshift(__in_close))
tr2 = abs(__in_low - fshift(__in_close))
__out_tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
__out_atr = wwm_mean_1d(__out_tr, __p_n)
__out_tr, __out_atr
```

Additionally, just as in regular Python code, you can place `print` statements to
explore the state at each step of execution:

```pycon
>>> expr = """
... ATR:
... tr0 = abs(@in_high - @in_low)
... print('tr0: ', tr0.shape)
... tr1 = abs(@in_high - fshift(@in_close))
... print('tr1: ', tr1.shape)
... tr2 = abs(@in_low - fshift(@in_close))
... print('tr2: ', tr2.shape)
... @out_tr = nanmax(column_stack((tr0, tr1, tr2)), axis=1)
... print('tr: ', @out_tr.shape)
... @out_atr = wwm_mean_1d(@out_tr, @p_n)
... print('atr: ', @out_atr.shape)
... @out_tr, @out_atr
... """
>>> ATR = vbt.IF.from_expr(expr, n=14)
>>> atr = ATR.run(ohlc['high'], ohlc['low'], ohlc['close'])
tr0:  (153, 1)
tr1:  (153, 1)
tr2:  (153, 1)
tr:  (153,)
atr:  (153,)
```

## WorldQuant's Alphas

[IndicatorFactory.from_wqa101](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_wqa101)
uses the expression parser to parse and execute [101 Formulaic Alphas](https://arxiv.org/pdf/1601.00991.pdf).
Each alpha expression is defined in [wqa101_expr_config](https://vectorbt.pro/pvt_6d1b3986/api/indicators/expr/#vectorbtpro.indicators.expr.wqa101_expr_config),
while most functions and resolved functions used in the alpha expressions are defined in
[expr_func_config](https://vectorbt.pro/pvt_6d1b3986/api/indicators/expr/#vectorbtpro.indicators.expr.expr_func_config) and 
[expr_res_func_config](https://vectorbt.pro/pvt_6d1b3986/api/indicators/expr/#vectorbtpro.indicators.expr.expr_res_func_config), respectively.

To get an indicator:

```pycon
>>> WQA53 = vbt.IF.from_wqa101(53)
>>> wqa53 = WQA53.run(ohlc['open'], ohlc['high'], ohlc['low'], ohlc['close'])
>>> wqa53.out
2019-12-31 00:00:00+00:00         NaN
2020-01-01 00:00:00+00:00         NaN
2020-01-02 00:00:00+00:00         NaN
2020-01-03 00:00:00+00:00         NaN
2020-01-04 00:00:00+00:00         NaN
                               ...   
2020-05-27 00:00:00+00:00    0.193719
2020-05-28 00:00:00+00:00   -0.858778
2020-05-29 00:00:00+00:00    0.452096
2020-05-30 00:00:00+00:00    0.376475
2020-05-31 00:00:00+00:00   -0.539368
Freq: D, Length: 153, dtype: float64
```

Or, use a shortcut:

```pycon
>>> vbt.wqa101(53)
vectorbtpro.indicators.factory.wqa101.WQA53
```

Replicating an alpha indicator is straightforward: look up its expression in the config and 
pass it to [IndicatorFactory.from_expr](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.from_expr):

```pycon
>>> WQA53 = vbt.IF.from_expr("-delta(((close - low) - (high - close)) / (close - low), 9)")
>>> wqa53 = WQA53.run(ohlc['open'], ohlc['high'], ohlc['low'], ohlc['close'])
>>> wqa53.out
2019-12-31 00:00:00+00:00         NaN
2020-01-01 00:00:00+00:00         NaN
2020-01-02 00:00:00+00:00         NaN
2020-01-03 00:00:00+00:00         NaN
2020-01-04 00:00:00+00:00         NaN
                               ...   
2020-05-27 00:00:00+00:00    0.193719
2020-05-28 00:00:00+00:00   -0.858778
2020-05-29 00:00:00+00:00    0.452096
2020-05-30 00:00:00+00:00    0.376475
2020-05-31 00:00:00+00:00   -0.539368
Freq: D, Length: 153, dtype: float64
```

[:material-language-python: Python code](https://vectorbt.pro/pvt_6d1b3986/assets/jupytext/documentation/indicators/parsers.py.txt){ .md-button target="blank_" }