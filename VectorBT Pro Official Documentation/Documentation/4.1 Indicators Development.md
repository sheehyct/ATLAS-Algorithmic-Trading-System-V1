---
title: Development
description: Documentation on developing indicators in VectorBT PRO
icon: material/order-bool-descending-variant
---

# :material-order-bool-descending-variant: Development

VBT offers a wide range of functions and arguments to simplify indicator development. All you
need is an indicator function and a way to specify how it should be handled.

## Parameters

[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory) allows
you to define any parameter grids you need. An indicator can have one or more parameters. Each
parameter can accept one or more values, which can be scalars (such as integers), arrays, or any
other objects.

If an indicator has multiple parameters, and one or more of them have several values, their values
will broadcast together. For example, if the parameter `w1` has only a single value `2` and the
parameter `w2` has two values `3` and `4`, then `w1` will be stretched to two values: `2` and `2`.
This allows the indicator to [zip](https://realpython.com/python-zip-function/) both parameters and
create two parameter combinations: `(2, 3)` and `(2, 4)`. The indicator will then iterate through
these combinations and apply a function to each one. The example below illustrates broadcasting:

```pycon
>>> from vectorbtpro import *

>>> def broadcast_params(*params):
...     return list(zip(*vbt.broadcast(*[vbt.to_1d_array(p) for p in params])))

>>> broadcast_params(2, 3)
[(2, 3)]

>>> broadcast_params([2, 3], 4)
[(2, 4), (3, 4)]

>>> broadcast_params(2, [3, 4])
[(2, 3), (2, 4)]

>>> broadcast_params([2, 3], [4, 5])
[(2, 4), (3, 5)]

>>> broadcast_params([2, 3], [4, 5, 6])
ValueError: Could not broadcast shapes: {0: (2,), 1: (3,)}
```

!!! note
    Do not confuse broadcasting with a product operation. The product of `[2, 3]` and `[4, 5]`
    would result in 4 combinations: `[2, 4]`, `[2, 5]`, `[3, 4]`, and `[3, 5]`. In broadcasting,
    smaller arrays are simply stretched to match the length of larger arrays for zipping.

To illustrate how parameters are used in indicators, here is a simple example. This indicator returns 1
when the rolling mean is above an upper bound, -1 when it is below a lower bound, and 0 when it is
between the upper and lower bounds:

```pycon
>>> def apply_func(ts, window, lower, upper):
...     out = np.full_like(ts, np.nan, dtype=float_)
...     ts_mean = vbt.nb.rolling_mean_nb(ts, window)
...     out[ts_mean >= upper] = 1
...     out[ts_mean <= lower] = -1
...     out[(ts_mean > lower) & (ts_mean < upper)] = 0
...     return out

>>> Bounded = vbt.IF(
...     class_name="Bounded",
...     input_names=['ts'],
...     param_names=['window', 'lower', 'upper'],
...     output_names=['out']
... ).with_apply_func(apply_func)

>>> def generate_index(n):
...     return vbt.date_range("2020-01-01", periods=n)

>>> ts = pd.DataFrame({
...     'a': [5, 4, 3, 2, 3, 4, 5],
...     'b': [2, 3, 4, 5, 4, 3, 2]
... }, index=generate_index(7))
>>> bounded = Bounded.run(ts, 2, 3, 5)
```

To retrieve the list of parameter names:

```pycon
>>> bounded.param_names
('window', 'lower', 'upper')
```

The broadcasted values of each parameter are accessible as attributes of the indicator instance,
using the parameter name followed by `_list`:

```pycon
>>> bounded.window_list
[2]
```

By default, when `per_column` is set to False, each parameter combination is applied to every
column in the input. For example, if your input array has 20 columns and you want to test 5
parameter combinations, you will get `20 * 5 = 100` columns in total.

A single parameter combination:

```pycon
>>> Bounded.run(
...     ts,
...     window=2,
...     lower=3,
...     upper=5
... ).out  # (1)!
bounded_window           2
bounded_lower            3
bounded_upper            5
                    a    b
2020-01-01        NaN  NaN
2020-01-02        0.0 -1.0
2020-01-03        0.0  0.0
2020-01-04       -1.0  0.0
2020-01-05       -1.0  0.0
2020-01-06        0.0  0.0
2020-01-07        0.0 -1.0
```

1. `2 * 1 = 2` output columns.

Multiple parameter combinations:

```pycon
>>> Bounded.run(
...     ts,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).out  # (1)!
bounded_window           2         3
bounded_lower            3         3
bounded_upper            5         5
                    a    b    a    b
2020-01-01        NaN  NaN  NaN  NaN
2020-01-02        0.0 -1.0  NaN  NaN
2020-01-03        0.0  0.0  0.0 -1.0
2020-01-04       -1.0  0.0 -1.0  0.0
2020-01-05       -1.0  0.0 -1.0  0.0
2020-01-06        0.0  0.0 -1.0  0.0
2020-01-07        0.0 -1.0  0.0 -1.0
```

1. `2 * 2 = 4` output columns.

Product of parameter combinations:

```pycon
>>> Bounded.run(
...     ts,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).out  # (1)!
bounded_window                     2                   3
bounded_lower            3         4         3         4
bounded_upper            5         5         5         5
                    a    b    a    b    a    b    a    b
2020-01-01        NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02        0.0 -1.0  0.0 -1.0  NaN  NaN  NaN  NaN
2020-01-03        0.0  0.0 -1.0 -1.0  0.0 -1.0 -1.0 -1.0
2020-01-04       -1.0  0.0 -1.0  0.0 -1.0  0.0 -1.0 -1.0
2020-01-05       -1.0  0.0 -1.0  0.0 -1.0  0.0 -1.0  0.0
2020-01-06        0.0  0.0 -1.0 -1.0 -1.0  0.0 -1.0 -1.0
2020-01-07        0.0 -1.0  0.0 -1.0  0.0 -1.0 -1.0 -1.0
```

1. `2 * 2 * 2 = 8` output columns.

You can build more complex parameter combinations using the
[generate_param_combs](https://vectorbt.pro/pvt_6d1b3986/api/utils/params/#vectorbtpro.utils.params.generate_param_combs) function.
For example, if the lower bound should always remain below the upper bound, you can control this
relationship using [itertools.combinations](https://docs.python.org/3/library/itertools.html#itertools.combinations).
After that, you can create a Cartesian product with the window using
[itertools.product](https://docs.python.org/3/library/itertools.html#itertools.product).

```pycon
>>> bound_combs_op = (combinations, [3, 4, 5], 2)
>>> product_op = (product, [2, 3], bound_combs_op)
>>> windows, lowers, uppers = vbt.generate_param_combs(product_op)  # (1)!

>>> Bounded.run(
...     ts,
...     window=windows,
...     lower=lowers,
...     upper=uppers
... ).out  # (2)!
bounded_window                               2                             3
bounded_lower                      3         4                   3         4
bounded_upper            4         5         5         4         5         5
                    a    b    a    b    a    b    a    b    a    b    a    b
2020-01-01        NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02        1.0 -1.0  0.0 -1.0  0.0 -1.0  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03        0.0  0.0  0.0  0.0 -1.0 -1.0  1.0 -1.0  0.0 -1.0 -1.0 -1.0
2020-01-04       -1.0  1.0 -1.0  0.0 -1.0  0.0 -1.0  1.0 -1.0  0.0 -1.0 -1.0
2020-01-05       -1.0  1.0 -1.0  0.0 -1.0  0.0 -1.0  1.0 -1.0  0.0 -1.0  0.0
2020-01-06        0.0  0.0  0.0  0.0 -1.0 -1.0 -1.0  1.0 -1.0  0.0 -1.0 -1.0
2020-01-07        1.0 -1.0  0.0 -1.0  0.0 -1.0  1.0 -1.0  0.0 -1.0 -1.0 -1.0
```

1. Each tuple represents a combinatoric operation. Tuples can accept other tuples as inputs.
2. `2 * 2 * 2 * 3 / 2 = 12` output columns.

One parameter combination per column:

```pycon
>>> Bounded.run(
...     ts,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).out  # (1)!
bounded_window      2    3
bounded_lower       3    4
bounded_upper       5    5
                    a    b
2020-01-01        NaN  NaN
2020-01-02        0.0  NaN
2020-01-03        0.0 -1.0
2020-01-04       -1.0 -1.0
2020-01-05       -1.0  0.0
2020-01-06        0.0 -1.0
2020-01-07        0.0 -1.0
```

1. The number of output columns matches the number of input columns.

### Defaults

Any argument passed to [IndicatorFactory.with_custom_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_custom_func)
that is not listed among the arguments of [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
is intended to be used as a default argument for the calculation function. Since most methods, including
[IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func),
call this method, you can easily set parameter defaults by passing them along with the function:

```pycon
>>> Bounded = vbt.IF(
...     class_name="Bounded",
...     input_names=['ts'],
...     param_names=['window', 'lower', 'upper'],
...     output_names=['out']
... ).with_apply_func(apply_func, window=2, lower=3, upper=4)

>>> Bounded.run(ts).out
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.0 -1.0
2020-01-03  0.0  0.0
2020-01-04 -1.0  1.0
2020-01-05 -1.0  1.0
2020-01-06  0.0  0.0
2020-01-07  1.0 -1.0

>>> Bounded.run(ts, upper=[5, 6]).out
bounded_upper           5         6
                   a    b    a    b
2020-01-01       NaN  NaN  NaN  NaN
2020-01-02       0.0 -1.0  0.0 -1.0
2020-01-03       0.0  0.0  0.0  0.0
2020-01-04      -1.0  0.0 -1.0  0.0
2020-01-05      -1.0  0.0 -1.0  0.0
2020-01-06       0.0  0.0  0.0  0.0
2020-01-07       0.0 -1.0  0.0 -1.0
```

The reason why the parameters `window` and `lower` do not appear in the column hierarchy above
is that default values are hidden by default. To display them, set `hide_default` to False:

```pycon
>>> Bounded.run(ts, hide_default=False).out
bounded_window           2     
bounded_lower            3     
bounded_upper            4     
                    a    b
2020-01-01        NaN  NaN
2020-01-02        1.0 -1.0
2020-01-03        0.0  0.0
2020-01-04       -1.0  1.0
2020-01-05       -1.0  1.0
2020-01-06        0.0  0.0
2020-01-07        1.0 -1.0
```

### Array-like

Some parameters are intended to be specified per row, column, or element of the input.
By default, if you pass a parameter value as an array, the indicator will treat this array
as a list of multiple values, one per input. To make the indicator interpret this array as a single value,
set the flag `is_array_like` to True in `param_settings`. To automatically broadcast the parameter value
to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can be broadcast per column, and both parameters
`lower` and `upper` can be broadcast per element. To enable this, we need
to rewrite `apply_func` to apply the rolling mean on each column instead of the entire input:

```pycon
>>> def apply_func(ts, window, lower, upper):  # (1)!
...     out = np.full_like(ts, np.nan, dtype=float_)
...     ts_means = []
...     for col in range(ts.shape[1]):
...         ts_means.append(vbt.nb.rolling_mean_1d_nb(ts[:, col], window[col]))
...     ts_mean = np.column_stack(ts_means)
...     out[ts_mean >= upper] = 1
...     out[ts_mean <= lower] = -1
...     out[(ts_mean > lower) & (ts_mean < upper)] = 0
...     return out

>>> Bounded = vbt.IF(
...     class_name="Bounded",
...     input_names=['ts'],
...     param_names=['window', 'lower', 'upper'],
...     output_names=['out']
... ).with_apply_func(
...     apply_func,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )
```

1. All parameters are now arrays that can broadcast against `ts`.

Both bound parameters can now be passed as a scalar (one value for the entire input), a one-dimensional
array (one value per row or column, depending on whether the input is a Series or a DataFrame),
a two-dimensional array (one value per element), or a list containing any of these. This approach allows
for maximum parameter flexibility.

For example, let's build a grid of two parameter combinations:

```pycon
>>> Bounded.run(
...     ts,
...     window=[np.array([2, 3]), 4],  # (1)!
...     lower=np.array([[1, 2]]),  # (2)!
...     upper=np.array([6, 5, 4, 3, 4, 5, 6]),  # (3)!
... ).out
bounded_window         2       3               4
bounded_lower    array_0 array_0 array_1 array_1  
bounded_upper    array_0 array_0 array_1 array_1
                       a       b       a       b
2020-01-01           NaN     NaN     NaN     NaN
2020-01-02           0.0     NaN     NaN     NaN
2020-01-03           0.0     0.0     NaN     NaN
2020-01-04           0.0     1.0     1.0     1.0
2020-01-05           0.0     1.0     0.0     1.0
2020-01-06           0.0     0.0     0.0     0.0
2020-01-07           0.0     0.0     0.0     0.0
```

1. One combination with a value per column and one with a value per input.
2. Value per column.
3. Value per row.

Our `apply_func` gets called twice, once for each parameter combination in `window`.
If you print the shapes of the passed arguments, you will see that each window array
now matches the number of columns in `ts`, while each bound array exactly matches the shape of `ts`:

```plaintext
Combination 1:
(7, 2)
(2,)
(7, 2)
(7, 2)

Combination 2:
(7, 2)
(2,)
(7, 2)
(7, 2)
```

### Lazy broadcasting

Broadcasting a large number of parameters to the input shape can use a lot of memory,
especially when the arrays are materialized. Fortunately, VBT can preserve the original (smaller)
dimensions of each parameter array and give you full control over broadcasting.
This requires setting `keep_flex` to True in `broadcast_kwargs`, which will make the factory first
check whether the array can be broadcast, and then expand it to either one or two dimensions in the most
memory-efficient way. There are two configs in [configs](https://vectorbt.pro/pvt_6d1b3986/api/indicators/configs) for this purpose:
one for column-wise broadcasting and one for element-wise broadcasting.

```pycon
>>> def apply_func(ts, window, lower, upper):
...     window = np.broadcast_to(window, ts.shape[1])  # (1)!
...     lower = np.broadcast_to(lower, ts.shape)
...     upper = np.broadcast_to(upper, ts.shape)
... 
...     out = np.full_like(ts, np.nan, dtype=float_)
...     ts_means = []
...     for col in range(ts.shape[1]):
...         ts_means.append(vbt.nb.rolling_mean_1d_nb(ts[:, col], window[col]))
...     ts_mean = np.column_stack(ts_means)
...     out[ts_mean >= upper] = 1
...     out[ts_mean <= lower] = -1
...     out[(ts_mean > lower) & (ts_mean < upper)] = 0
...     return out

>>> Bounded = vbt.IF(
...     class_name="Bounded",
...     input_names=['ts'],
...     param_names=['window', 'lower', 'upper'],
...     output_names=['out']
... ).with_apply_func(
...     apply_func,
...     param_settings=dict(
...         window=vbt.flex_col_param_config,
...         lower=vbt.flex_elem_param_config,
...         upper=vbt.flex_elem_param_config
...     )
... )
```

1. Bring to the full shape.

Well done! This is the most flexible and memory-efficient way to implement an indicator.
Instead of broadcasting all array-like parameter values immediately, we delay this operation
until it is actually needed.

#### With Numba

The implementation above is very flexible, but it is not the most optimized because it iterates over the
input shape multiple times. As a bonus, let's rewrite our `apply_func` to be Numba-compiled:
this version will iterate over columns and rows, select each parameter value
[flexibly](https://vectorbt.pro/pvt_6d1b3986/documentation/fundamentals/#flexible-indexing) without any broadcasting,
and fill the output array step by step.

```pycon
>>> @njit
... def apply_func_nb(ts, window, lower, upper):
...     out = np.full_like(ts, np.nan, dtype=float_)
...
...     for col in range(ts.shape[1]):
...         _window = vbt.flex_select_1d_pc_nb(window, col)  # (1)!
...
...         for row in range(ts.shape[0]):
...             window_start = max(0, row + 1 - _window)
...             window_end = row + 1
...             if window_end - window_start >= _window:
...                 _lower = vbt.flex_select_nb(lower, row, col)  # (2)!
...                 _upper = vbt.flex_select_nb(upper, row, col)  # (3)!
...
...                 mean = np.nanmean(ts[window_start:window_end, col])  # (4)!
...                 if mean >= _upper:
...                     out[row, col] = 1
...                 elif mean <= _lower:
...                     out[row, col] = -1
...                 elif _lower < mean < _upper:
...                     out[row, col] = 0
...     return out
```

1. Get the window defined for this column.
2. Get the lower bound defined for this element.
3. Get the upper bound defined for this element.
4. Get the mean of this window.

!!! hint
    This is perfectly valid Python code. Even if you remove the `@njit` decorator, it will still work!

Remember that executing code compiled with Numba can provide performance increases
many times greater than standard Python and even Pandas :snail:

### Parameterless

Indicators can also be parameterless, such as [OBV](https://vectorbt.pro/pvt_6d1b3986/api/indicators/custom/obv/#vectorbtpro.indicators.custom.obv.OBV).

## Inputs

[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory) allows you 
to pass none, one, or multiple inputs. If multiple inputs are provided, it will try to broadcast them 
into a single shape using [broadcast](https://vectorbt.pro/pvt_6d1b3986/api/base/reshaping/#vectorbtpro.base.reshaping.broadcast)
(see [Broadcasting](https://vectorbt.pro/pvt_6d1b3986/documentation/fundamentals/#broadcasting)).

Remember, in VBT each column represents a separate backtest. So, to work with multiple
pieces of data such as OHLCV, you should provide them as separate Pandas objects, not as a single
monolithic DataFrame (see [Multidimensionality](https://vectorbt.pro/pvt_6d1b3986/documentation/fundamentals/#multidimensionality)).

Let's create a parameterless indicator that calculates the position of the closing price relative to
the candle:

```pycon
>>> def apply_func(high, low, close):
...     return (close - low) / (high - low)

>>> RelClose = vbt.IF(
...     input_names=['high', 'low', 'close'],
...     output_names=['out']
... ).with_apply_func(apply_func)

>>> close = pd.Series([1, 2, 3, 4, 5], index=generate_index(5))
>>> high = close * 1.2
>>> low = close * 0.8

>>> rel_close = RelClose.run(high, low, close)
>>> rel_close.out
2020-01-01    0.5
2020-01-02    0.5
2020-01-03    0.5
2020-01-04    0.5
2020-01-05    0.5
dtype: float64
```

To see the list of input names:

```pycon
>>> rel_close.input_names
('high', 'low', 'close')
```

You can access any (broadcasted and tiled) input array as an attribute of the indicator instance:

```pycon
>>> rel_close.high
2020-01-01    1.2
2020-01-02    2.4
2020-01-03    3.6
2020-01-04    4.8
2020-01-05    6.0
dtype: float64
```

!!! note
    The input array attached to the indicator instance may look different from what you passed in:
    1) it has been broadcasted with the other inputs, and 2) when you access the attribute, it is
    automatically tiled by the number of parameter combinations to make it easier to compare with
    outputs. To access the original array, prepend an underscore (`_high`).

To demonstrate broadcasting, let's pass `high` as a scalar, `low` as a Series, and `close` as a DataFrame
(even if this combination does not make sense):

```pycon
>>> high = 10
>>> low = pd.Series([1, 2, 3, 4, 5], index=generate_index(5))
>>> close = pd.DataFrame({
...     'a': [3, 2, 1, 2, 3],
...     'b': [5, 4, 3, 4, 5]
... }, index=generate_index(5))
>>> RelClose.run(high, low, close).out
                   a         b
2020-01-01  0.222222  0.444444
2020-01-02  0.000000  0.250000
2020-01-03 -0.285714  0.000000
2020-01-04 -0.333333  0.000000
2020-01-05 -0.400000  0.000000
```

!!! hint
    By default, if all inputs are Series, they are automatically converted into two-dimensional NumPy
    arrays. This provides a unified array interface, as most VBT functions mainly
    work with two-dimensional data. To keep their original dimensions, set `to_2d` to False in
    [IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func)
    or any other factory method.

To change broadcasting rules, you can pass a dict called `broadcast_kwargs`, which is unpacked and
forwarded to [broadcast](https://vectorbt.pro/pvt_6d1b3986/api/base/reshaping/#vectorbtpro.base.reshaping.broadcast). For example,
let's tell the broadcaster to cast all three arrays to `np.float16`:

```pycon
>>> RelClose.run(
...     high, low, close,
...     broadcast_kwargs=dict(require_kwargs=dict(dtype=np.float16))
... ).out.dtypes
a    float16
b    float16
dtype: object
```

!!! hint
    Remember that any additional keyword arguments passed to a `run` method are
    forwarded to [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline).
    This allows you to set up the pipeline during both indicator creation and execution.

Since all arrays are passed directly to [broadcast](https://vectorbt.pro/pvt_6d1b3986/api/base/reshaping/#vectorbtpro.base.reshaping.broadcast),
you can also wrap any of them using the [BCO](https://vectorbt.pro/pvt_6d1b3986/api/base/reshaping/#vectorbtpro.base.reshaping.BCO) class
to override broadcasting rules for that particular array only:

```pycon
>>> RelClose.run(
...     vbt.BCO(high, require_kwargs=dict(dtype=np.float16)), 
...     vbt.BCO(low, require_kwargs=dict(dtype=np.float16)), 
...     vbt.BCO(close, require_kwargs=dict(dtype=np.float16))
... ).out.dtypes
a    float16
b    float16
dtype: object
```

### One dim

Sometimes, adapting your indicator function to work with two-dimensional data is not straightforward.
For example, when using a TA-Lib indicator in `apply_func`, you may need to pass only one column at a
time. To instruct [IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func)
to split any input and in-place output (Pandas or NumPy) array by column, use the `takes_1d` argument:

```pycon
>>> import talib

>>> def apply_func_1d(close, timeperiod):
...     return talib.SMA(close.astype(np.double), timeperiod)

>>> SMA = vbt.IF(
...     input_names=['ts'],
...     param_names=['timeperiod'],
...     output_names=['sma']
... ).with_apply_func(apply_func_1d, takes_1d=True)

>>> sma = SMA.run(ts, [3, 4])
>>> sma.sma
custom_timeperiod                   3         4
                          a         b    a    b
2020-01-01              NaN       NaN  NaN  NaN
2020-01-02              NaN       NaN  NaN  NaN
2020-01-03         4.000000  3.000000  NaN  NaN
2020-01-04         3.000000  4.000000  3.5  3.5
2020-01-05         2.666667  4.333333  3.0  4.0
2020-01-06         3.000000  4.000000  3.0  4.0
2020-01-07         4.000000  3.000000  3.5  3.5
```

!!! note
    Do not confuse this with `per_column`, which also splits by column but applies one parameter
    combination to one column instead of all columns.

### Defaults

Just like with parameters, you can define defaults for your inputs:

```pycon
>>> RelClose = vbt.IF(
...     input_names=['high', 'low', 'close'],
...     output_names=['out']
... ).with_apply_func(
...     apply_func,
...     high=0,
...     low=10
... )

>>> RelClose.run(close).out
              a    b
2020-01-01  0.7  0.5
2020-01-02  0.8  0.6
2020-01-03  0.9  0.7
2020-01-04  0.8  0.6
2020-01-05  0.7  0.5
```

However, unlike parameters, setting inputs to scalars is often not ideal.
Instead, you may want to set them to other inputs, which is possible using 
[Ref](https://vectorbt.pro/pvt_6d1b3986/api/base/reshaping/#vectorbtpro.base.reshaping.Ref):

```pycon
>>> RelClose = vbt.IF(
...     input_names=['high', 'low', 'close'],
...     output_names=['out']
... ).with_apply_func(
...     apply_func,
...     high=vbt.Ref('close'),
...     low=vbt.Ref('close')
... )

>>> RelClose.run(high=high, close=close).out
              a    b
2020-01-01  0.0  0.0
2020-01-02  0.0  0.0
2020-01-03  0.0  0.0
2020-01-04  0.0  0.0
2020-01-05  0.0  0.0
```

### Using Pandas

Working only with NumPy arrays is not always the best choice: sometimes you want to take
advantage of Pandas metadata or VBT's Pandas extensions. To prevent conversion of Pandas 
objects to NumPy arrays, you can set `keep_pd` to True.

For example, let's create an indicator that takes a DataFrame and normalizes it against the mean of
each group of columns. The interesting part is that the `group_by` for grouping columns will be a
parameter!

```pycon
>>> def apply_func(ts, group_by):
...     return ts.vbt.demean(group_by=group_by)

>>> Demeaner = vbt.IF(
...     input_names=['ts'],
...     param_names=['group_by'],
...     output_names=['out']
... ).with_apply_func(apply_func, keep_pd=True)

>>> ts_wide = pd.DataFrame({
...     'a': [1, 2, 3, 4, 5],
...     'b': [5, 4, 3, 2, 1],
...     'c': [3, 2, 1, 2, 3],
...     'd': [1, 2, 3, 2, 1]
... }, index=generate_index(5))
>>> demeaner = Demeaner.run(ts_wide, group_by=[(0, 0, 1, 1), True])
>>> demeaner.out
custom_group_by                tuple_0                True
                      a    b    c    d    a    b    c    d
2020-01-01         -2.0  2.0  1.0 -1.0 -1.5  2.5  0.5 -1.5
2020-01-02         -1.0  1.0  0.0  0.0 -0.5  1.5 -0.5 -0.5
2020-01-03          0.0  0.0 -1.0  1.0  0.5  0.5 -1.5  0.5
2020-01-04          1.0 -1.0  0.0  0.0  1.5 -0.5 -0.5 -0.5
2020-01-05          2.0 -2.0  1.0 -1.0  2.5 -1.5  0.5 -1.5
```

Alternatively, you can have [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
pass inputs as NumPy arrays, along with a [wrapper](https://vectorbt.pro/pvt_6d1b3986/documentation/building-blocks/#wrapping)
that includes the Pandas metadata:

```pycon
>>> def apply_func(ts, group_by, wrapper):  # (1)!
...     group_map = wrapper.grouper.get_group_map(group_by=group_by)
...     return vbt.nb.demean_nb(ts, group_map)

>>> Demeaner = vbt.IF(
...     input_names=['ts'],
...     param_names=['group_by'],
...     output_names=['out']
... ).with_apply_func(apply_func, pass_wrapper=True)
```

1. `ts` is a two-dimensional NumPy array, which can be used in most Numba-compiled 
functions provided by VBT.

### Inputless

What if an indicator does not take any input arrays? For example, you may want to create an indicator
that takes an input shape, creates one or more output arrays of that shape, and fills them using
information provided as additional arguments. To do this, you can require the user to provide an input
shape using `require_input_shape`.

Let's define a generator that emulates random returns and generates a synthetic price.
This is a parameterized way of implementing [RandomData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/random/#vectorbtpro.data.custom.random.RandomData):

```pycon
>>> def apply_func(input_shape, start, mean, std):
...     rand_returns = np.random.normal(mean, std, input_shape)
...     return start * np.cumprod(1 + rand_returns, axis=0)

>>> RandPrice = vbt.IF(
...     class_name="RandPrice",
...     param_names=['start', 'mean', 'std'],
...     output_names=['out']
... ).with_apply_func(
...     apply_func,
...     require_input_shape=True,
...     start=100,  # (1)!
...     mean=0,  # (2)!
...     std=0.01,  # (3)!
...     seed=42  # (4)!
... )

>>> RandPrice.run((5, 2)).out
            0           1
0  100.496714   99.861736
1  101.147620  101.382660
2  100.910779  101.145285
3  102.504375  101.921510
4  102.023143  102.474495
```

1. Default starting value.
2. Default mean ("center") of the distribution.
3. Default standard deviation (spread or "width") of the distribution.
4. [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
supports random seeds.

!!! info
    When `require_input_shape` is True, [IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory)
    prepends an `input_shape` argument to the `run` method's signature. Without this argument,
    the `apply_func` itself must determine the input shape.

However, having integer columns and index is not very convenient. Fortunately, VBT allows you to
pass `input_index` and `input_columns`!

```pycon
>>> RandPrice.run(
...     (5, 2),
...     input_index=generate_index(5),
...     input_columns=['a', 'b'],
...     mean=[-0.1, 0.1]
... ).out
randprice_mean                  -0.1                     0.1
                        a          b           a           b
2020-01-01      90.496714  89.861736  109.536582  109.534270
2020-01-02      82.033180  82.244183  120.755278  118.392000
2020-01-03      73.637778  73.827201  130.747876  129.565496
2020-01-04      67.436898  67.011056  142.498409  142.929202
2020-01-05      60.376609  60.673526  155.454330  155.203528
```

You can even build an indicator that decides on the output shape dynamically.
Let's create a fun indicator that returns an array with a random shape:

```pycon
>>> def custom_func(min_rows=1, max_rows=5, min_cols=1, max_cols=3):  # (1)!
...     n_rows = np.random.randint(min_rows, max_rows)
...     n_cols = np.random.randint(min_cols, max_cols)
...     return np.random.uniform(size=(n_rows, n_cols))

>>> RandShaped = vbt.IF(
...     output_names=['out']
... ).with_custom_func(custom_func)

>>> RandShaped.run(seed=42).out
          0         1
0  0.950714  0.731994
1  0.598658  0.156019
2  0.155995  0.058084

>>> RandShaped.run(seed=43).out
0    0.609067
dtype: float64

>>> RandShaped.run(seed=44).out
          0        1
0  0.104796  0.74464
```

1. We use `custom_func` instead of `apply_func` because this indicator cannot be parameterized, and
no iteration takes place.

## Outputs

[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory)
supports returning one or more outputs. There are two types of outputs: regular outputs and
in-place outputs (also called "in-place outputs").

### Regular

Regular outputs are arrays explicitly returned by the calculation function. Each output must have
the same shape and match the number of columns in the input, multiplied by the number of parameter
combinations. This requirement only needs special attention when using `custom_func`, as `apply_func`
handles the tiling automatically. If there is only one output, an array must be returned. If there are
multiple outputs, a tuple containing multiple arrays must be returned.

Let's demonstrate multiple regular outputs by computing and returning the entries and exits
from a moving average crossover:

```pycon
>>> def apply_func(ts, fastw, sloww, minp=None):
...     fast_ma = vbt.nb.rolling_mean_nb(ts, fastw, minp=minp)
...     slow_ma = vbt.nb.rolling_mean_nb(ts, sloww, minp=minp)
...     entries = vbt.nb.crossed_above_nb(fast_ma, slow_ma)
...     exits = vbt.nb.crossed_above_nb(slow_ma, fast_ma)
...     return (fast_ma, slow_ma, entries, exits)  # (1)!

>>> CrossSig = vbt.IF(
...     class_name="CrossSig",
...     input_names=['ts'],
...     param_names=['fastw', 'sloww'],
...     output_names=['fast_ma', 'slow_ma', 'entries', 'exits']
... ).with_apply_func(apply_func)

>>> ts2 = pd.DataFrame({
...     'a': [1, 2, 3, 2, 1, 2, 3],
...     'b': [3, 2, 1, 2, 3, 2, 1]
... }, index=generate_index(7))
>>> cross_sig = CrossSig.run(ts2, 2, 4)
```

1. Also return the fast and slow moving average for analysis.

!!! important
    Any output registered in `output_names` must have the same shape as the broadcasted inputs.
    This requirement makes it possible to index the indicator instance.

To get the list of output names:

```pycon
>>> cross_sig.output_names
('fast_ma', 'slow_ma', 'entries', 'exits')
```

Any (broadcasted and tiled) output array can be accessed as an attribute of the indicator instance:

```pycon
>>> cross_sig.entries
crosssig_fastw      2      2
crosssig_sloww      4      4
                    a      b
2020-01-01      False  False
2020-01-02      False  False
2020-01-03      False  False
2020-01-04      False  False
2020-01-05      False   True
2020-01-06      False  False
2020-01-07       True  False
```

### In-place

In-place outputs are arrays that are not returned but modified in place. They act as regular inputs
when entering the pipeline and as regular outputs when exiting. In particular:

1. They broadcast together with regular inputs if provided. Otherwise, an empty array is created.
2. They are tiled by the number of hyperparameter combinations.
3. Each tile is modified in place (they are **not** returned).
4. After calculation, all the tiles are concatenated to form an output.

By default, in-place outputs are created as empty arrays with uninitialized floating point values.
This allows for the creation of optional outputs that, if not written to, do not consume much memory.
Since not all outputs should have the `float` data type, you can pass `dtype` in the
`in_output_settings`.

Let's modify the indicator above by converting both signal arrays to in-place outputs:

```pycon
>>> def apply_func(ts, entries, exits, fastw, sloww, minp=None):
...     fast_ma = vbt.nb.rolling_mean_nb(ts, fastw, minp=minp)
...     slow_ma = vbt.nb.rolling_mean_nb(ts, sloww, minp=minp)
...     entries[:] = vbt.nb.crossed_above_nb(fast_ma, slow_ma)  # (1)!
...     exits[:] = vbt.nb.crossed_above_nb(slow_ma, fast_ma)
...     return (fast_ma, slow_ma)  # (2)!

>>> CrossSig = vbt.IF(
...     class_name="CrossSig",
...     input_names=['ts'],
...     in_output_names=['entries', 'exits'],
...     param_names=['fastw', 'sloww'],
...     output_names=['fast_ma', 'slow_ma']
... ).with_apply_func(
...     apply_func,
...     in_output_settings=dict(
...         entries=dict(dtype=np.bool_),  # (3)!
...         exits=dict(dtype=np.bool_)
...     )
... )
>>> cross_sig = CrossSig.run(ts2, 2, 4)
```

1. Both arrays are modified in place.
2. Both arrays are no longer returned.
3. Instruct [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
to initialize both signal arrays with the boolean data type.

If you print the `output_names`, you will see that `entries` and `exits` are no longer included:

```pycon
>>> cross_sig.output_names
('fast_ma', 'slow_ma')
```

To see all in-place output arrays, use the `in_output_names` attribute:

```pycon
>>> cross_sig.in_output_names
('entries', 'exits')
```

Both signal arrays can be accessed as usual:

```pycon
>>> cross_sig.entries
crosssig_fastw             2
crosssig_sloww             4
                    a      b
2020-01-01      False  False
2020-01-02      False  False
2020-01-03      False  False
2020-01-04      False  False
2020-01-05      False   True
2020-01-06      False  False
2020-01-07       True  False
```

!!! hint
    An interesting scenario occurs when there are no regular outputs, only in-place outputs.
    In this case, you should set `output_names` to an empty list, modify all arrays in place,
    and return `None`. See the example below.

#### Defaults

You might be wondering: *"Why should we bother using in-place outputs when we can just return regular
outputs?"* The answer is that we can provide custom data and overwrite it without using additional
memory. Consider the following example, where we keep the first `n` signals in a boolean time
series:

```pycon
>>> @njit
... def apply_func_nb(signals, n):
...     for col in range(signals.shape[1]):
...         n_found = 0
...         for row in range(signals.shape[0]):
...             if signals[row, col]:
...                 if n_found >= n:
...                     signals[row, col] = False
...                 else:
...                     n_found += 1

>>> FirstNSig = vbt.IF(
...     class_name="FirstNSig",
...     in_output_names=['signals'],
...     param_names=['n']
... ).with_apply_func(apply_func_nb)

>>> signals = pd.Series([False, True, True, True, False])
>>> first_n_sig = FirstNSig.run([1, 2, 3], signals=signals)
>>> first_n_sig.signals
firstnsig_n      1      2      3
0            False  False  False
1             True   True   True
2            False   True   True
3            False  False   True
4            False  False  False
```

As you can see, one array fulfills the job of two, and this is done without modifying the passed
`signals` array!

```pycon
>>> signals
0    False
1     True
2     True
3     True
4    False
dtype: bool
```

!!! note
    Unlike regular inputs, none of the in-place outputs is required when running an indicator,
    so they appear in the signature of the `run` method as keyword arguments with `None` as the
    default value. Be sure to pass each in-place output as a keyword argument after other positional
    arguments (such as inputs and parameters).

### Extra

Any additional output returned by `custom_func` that is not registered in `output_names`
is returned in a raw format along with the indicator instance. Such outputs can be objects
of any type, especially arrays whose shapes differ from those of the inputs.
They are not included in the indicator instance because the indicator factory does not know how
to wrap, index, and analyze them; only the user does. For example, let's return the rolling
mean along with its maximum in each column:

```pycon
>>> def custom_func(ts, window):  # (1)!
...     ts_mas = []
...     ts_ma_maxs = []
...     for w in window:
...         ts_ma = vbt.nb.rolling_mean_nb(ts, w)
...         ts_mas.append(ts_ma)
...         ts_ma_maxs.append(np.nanmax(ts_ma, axis=0))
...     return np.column_stack(ts_mas), np.concatenate(ts_ma_maxs)

>>> MAMax = vbt.IF(
...     class_name='MAMax',
...     input_names=['ts'],
...     param_names=['window'],
...     output_names=['ma'],
... ).with_custom_func(custom_func)

>>> ma_ind, ma_max = MAMax.run(ts2, [2, 3])  # (2)!
>>> ma_ind
mamax_window         2                   3
                a    b         a         b
2020-01-01    NaN  NaN       NaN       NaN
2020-01-02    1.5  2.5       NaN       NaN
2020-01-03    2.5  1.5  2.000000  2.000000
2020-01-04    2.5  1.5  2.333333  1.666667
2020-01-05    1.5  2.5  2.000000  2.000000
2020-01-06    1.5  2.5  1.666667  2.333333
2020-01-07    2.5  1.5  2.000000  2.000000

>>> ma_ind.wrapper.wrap_reduced(ma_max)  # (3)!
mamax_window   
2             a    2.500000
              b    2.500000
3             a    2.333333
              b    2.333333
dtype: float64
```

1. `apply_func` does not support extra outputs, only `custom_func`.
2. Extra outputs are returned along with the indicator instance.
3. Wrap the reduced array using the wrapper of the indicator instance.

### Lazy

Use the `lazy_outputs` argument when constructing an indicator to define lazy outputs—
outputs that are computed from "normal" outputs and are only calculated when explicitly requested.
They are available as regular cacheable properties of the indicator instance and can be of
any type. Continuing with the previous example, let's add a cached property that returns
the maximum of the rolling mean:

```pycon
>>> MAMax = vbt.IF(
...     class_name='MAMax',
...     input_names=['ts'],
...     param_names=['window'],
...     output_names=['ma'],
...     lazy_outputs=dict(
...         ma_max=vbt.cached_property(lambda self: self.ma.max())
...     )
... ).with_apply_func(vbt.nb.rolling_mean_nb)

>>> ma_ind = MAMax.run(ts2, [2, 3])
>>> ma_ind.ma_max
mamax_window   
2             a    2.500000
              b    2.500000
3             a    2.333333
              b    2.333333
dtype: float64
```

!!! hint
    You can achieve the same result by subclassing `MAMax` and defining the property in the subclass.

## Custom arguments

Sometimes, you may need to pass arguments that are not inputs, in-place outputs, or parameters.

### Optional

If you review the `apply_func` of `CrossSig`, you will notice it takes another optional argument, `minp`,
which controls the minimum number of observations in a window required to have a value.
Listing a keyword argument with its default in `custom_func` or `apply_func` is one way to
provide a default value. Another way is to make the argument positional and provide its default 
to [IndicatorFactory.with_custom_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_custom_func)
or another factory method. The default can also be set during execution in the `run` method.

### Variable

Variable arguments, often appearing as `*args`, are used to accept a *variable* number of arguments.
To enable variable arguments, you need to set `var_args` to True. The reason is as follows: when
[IndicatorFactory.with_custom_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_custom_func)
builds the `run` method, it must rearrange the arguments so that required arguments appear
before optional arguments. Without the `var_args` flag, the `run` method does not expect any 
additional positional arguments to be passed, which can lead to an error or, even worse, a corrupted result.

Let's add a variable number of inputs:

```pycon
>>> def custom_func(*arrs):
...     out = None
...     for arr in arrs:
...         if out is None:
...             out = arr
...         else:
...             out += arr
...     return out

>>> VarArgAdder = vbt.IF(
...     output_names=['out']  # (1)!
... ).with_custom_func(custom_func, var_args=True)

>>> VarArgAdder.run(
...     pd.Series([1, 2, 3]),
...     pd.Series([10, 20, 30]),
...     pd.Series([100, 200, 300])
... ).out
0    111
1    222
2    333
dtype: int64
```

1. No inputs.

!!! note
    The indicator above is effectively inputless: inputs that are not registered in `input_names` 
    will not broadcast automatically and are not available as attributes of an indicator instance.

### Positional

Positional arguments are handled in the same way as variable arguments.

### Keyword-only

You can set `keyword_only_args` to True to require that all arguments be used as keyword-only arguments.
This can help avoid accidentally placing arguments in the wrong position. 

For example, consider the `RelClose` indicator:

```pycon
>>> def apply_func(high, low, close):
...     return (close - low) / (high - low)

>>> RelClose = vbt.IF(
...     input_names=['high', 'low', 'close'],
...     output_names=['out']
... ).with_apply_func(apply_func)

>>> RelClose.run(close, high, low).out  # (1)!
                   a         b
2020-01-01  1.285714  1.800000
2020-01-02  1.000000  1.333333
2020-01-03  0.777778  1.000000
2020-01-04  0.750000  1.000000
2020-01-05  0.714286  1.000000

>>> RelClose = vbt.IF(
...     input_names=['high', 'low', 'close'],
...     output_names=['out']
... ).with_apply_func(apply_func, keyword_only_args=True)

>>> RelClose.run(close, high, low).out  # (2)!
TypeError: run() takes 1 positional argument but 4 were given

>>> RelClose.run(close=close, high=high, low=low).out  # (3)!
                   a         b
2020-01-01  0.222222  0.444444
2020-01-02  0.000000  0.250000
2020-01-03 -0.285714  0.000000
2020-01-04 -0.333333  0.000000
2020-01-05 -0.400000  0.000000
```

1. `close` is incorrectly passed as the high price—no error is thrown!
2. An error is shown, meaning you must use keyword arguments.
3. `close` is now correctly passed as the closing price.

## Built-in caching

[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory) 
reuses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and parameter combinations may get repeated,
preventing the repeated processing of the same parameter combination is essential for 
good performance.

First, look at a typical raw output by passing repeated parameter combinations
and setting `return_raw` to True:

```pycon
>>> raw = vbt.MA.run(
...     ts2, 
...     window=[2, 2, 3], 
...     wtype=["simple", "simple", "exp"],  # (1)!
...     return_raw=True)
>>> raw
([array([[     nan,      nan,      nan,      nan,      nan,      nan],
         [1.5     , 2.5     , 1.5     , 2.5     ,      nan,      nan],
         [2.5     , 1.5     , 2.5     , 1.5     , 2.25    , 1.75    ],
         [2.5     , 1.5     , 2.5     , 1.5     , 2.125   , 1.875   ],
         [1.5     , 2.5     , 1.5     , 2.5     , 1.5625  , 2.4375  ],
         [1.5     , 2.5     , 1.5     , 2.5     , 1.78125 , 2.21875 ],
         [2.5     , 1.5     , 2.5     , 1.5     , 2.390625, 1.609375]])],
 [(2, 0), (2, 0), (3, 2)],
 2,
 [])
```

1. Three parameter combinations, with two of them being identical.

The raw output consists of:

1. The list of returned output arrays.
2. The list of zipped parameter combinations.
3. The number of input columns.
4. Other objects returned along with output arrays but not listed in `output_names`.

!!! info
    A raw output represents the context of running an indicator. If any parameter combination
    appears in the list of zipped parameter combinations, it means that it was actually run, not cached.

You can see that the calculation function was executed for the same parameter combination twice.
This is not a problem if your calculation is fast enough that you do not mind re-running
the same procedure. However, if your indicator is very complex and slow to compute,
you can instruct [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
to run the indicator on unique parameter combinations only by passing `run_unique`:

```pycon
>>> raw = vbt.MA.run(
...     ts2, 
...     window=[2, 2, 3], 
...     wtype=["simple", "simple", "exp"], 
...     return_raw=True, 
...     run_unique=True, 
...     silence_warnings=True)  # (1)!
>>> raw
([array([[     nan,      nan,      nan,      nan],
         [1.5     , 2.5     ,      nan,      nan],
         [2.5     , 1.5     , 2.25    , 1.75    ],
         [2.5     , 1.5     , 2.125   , 1.875   ],
         [1.5     , 2.5     , 1.5625  , 2.4375  ],
         [1.5     , 2.5     , 1.78125 , 2.21875 ],
         [2.5     , 1.5     , 2.390625, 1.609375]])],
 [(2, 0), (3, 2)],
 2,
 [])
```

1. Without `silence_warnings`, you would get a warning that the raw output contains
only unique parameter combinations. You can ignore this.

Let's compare the performance of running the same parameter combination repeatedly
with and without `run_unique`:

```pycon
>>> a = np.random.uniform(size=(1000,))

>>> %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
11.6 ms ± 1.26 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)

>>> %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
5.91 ms ± 220 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! hint
    The moving average is one of the fastest indicators available. Try this example on a more complex 
    indicator to see the impact of built-in caching.

As a rule of thumb:

* Enable `run_unique` if input arrays have few columns, the calculation function is slow, and 
there are duplicates among parameter combinations.
* Disable `run_unique` if input arrays have many columns, the calculation function is very fast, or 
if two identical parameter combinations can lead to different results (for example, when using
a `custom_func` that makes decisions based on the entire parameter grid, or when there is some 
randomness involved).

!!! note
    `run_unique` is disabled by default.

### Reusing cache

Internally, `run_unique` uses the raw output computed from unique parameter combinations to produce 
the output for all parameter combinations. But what if you already have your own raw output?
You can pass it as `use_raw`. This does not call the calculation function, but instead stacks raw outputs 
in the order their parameter combinations appear in the requested grid. If some requested parameter 
combinations cannot be found in `use_raw`, it will raise an error:

```pycon
>>> raw = vbt.MA.run(
...     ts2, 
...     window=[2, 3], 
...     wtype=["simple", "exp"],
...     return_raw=True)
>>> vbt.MA.run(ts2, 2, "simple", use_raw=raw).ma
ma_window            2     
ma_wtype        simple     
                a    b
2020-01-01    NaN  NaN
2020-01-02    1.5  2.5
2020-01-03    2.5  1.5
2020-01-04    2.5  1.5
2020-01-05    1.5  2.5
2020-01-06    1.5  2.5
2020-01-07    2.5  1.5

>>> vbt.MA.run(ts2, 2, "exp", use_raw=raw).ma
ValueError: (2, 2) is not in list
```

This allows you to pre-compute indicators.

## Manual caching

Another performance boost can be achieved by caching manually, which must be implemented
inside `custom_func`. Additionally, `custom_func` must accept a `return_cache` argument 
to return the cache and a `use_cache` argument to reuse the cache 
(similar to `return_raw` and `use_raw`). Fortunately,
[IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func)
accepts a `cache_func` and provides a `custom_func` that meets these requirements.

Consider this scenario: you want to calculate the relative distance between two 
computationally expensive rolling windows. You have already decided on the value for the first window, 
and want to test thousands of values for the second window. Without caching, and even with `run_unique` 
enabled, the first rolling window will be recalculated many times, wasting resources:

```pycon
>>> def roll_mean_expensive_nb(ts, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(ts, w)
...     return out

>>> def apply_func(ts, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(ts, w1)
...     roll_mean2 = roll_mean_expensive_nb(ts, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

>>> RelMADist = vbt.IF(
...     class_name="RelMADist",
...     input_names=['ts'],
...     param_names=['w1', 'w2'],
...     output_names=['out'],
... ).with_apply_func(apply_func)

>>> RelMADist.run(ts2, 2, 3).out
relmadist_w1                   2
relmadist_w2                   3
                     a         b
2020-01-01         NaN       NaN
2020-01-02         NaN       NaN
2020-01-03   -0.200000  0.333333
2020-01-04   -0.066667  0.111111
2020-01-05    0.333333 -0.200000
2020-01-06    0.111111 -0.066667
2020-01-07   -0.200000  0.333333

>>> %timeit RelMADist.run(ts2, 2, np.arange(2, 1000))
294 ms ± 52.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, pre-compute all unique rolling windows in `cache_func` and use them in `apply_func`:

```pycon
>>> def cache_func(ts, w1, w2):  # (1)!
...     cache_dict = dict()
...     for w in w1 + w2:
...         if w not in cache_dict:
...             cache_dict[w] = roll_mean_expensive_nb(ts, w)
...     return cache_dict

>>> def apply_func(ts, w1, w2, cache_dict):  # (2)!
...     return (cache_dict[w2] - cache_dict[w1]) / cache_dict[w1]

>>> RelMADist = vbt.IF(
...     class_name="RelMADist",
...     input_names=['ts'],
...     param_names=['w1', 'w2'],
...     output_names=['out'],
... ).with_apply_func(apply_func, cache_func=cache_func)

>>> RelMADist.run(ts2, 2, 3).out
relmadist_w1                   2
relmadist_w2                   3
                     a         b
2020-01-01         NaN       NaN
2020-01-02         NaN       NaN
2020-01-03   -0.200000  0.333333
2020-01-04   -0.066667  0.111111
2020-01-05    0.333333 -0.200000
2020-01-06    0.111111 -0.066667
2020-01-07   -0.200000  0.333333

>>> %timeit RelMADist.run(ts2, 2, np.arange(2, 1000))
119 ms ± 335 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

1. `cache_func` accepts the same arguments as `apply_func`, but parameters are now lists 
instead of single values.
2. `apply_func` accepts the output of `cache_func` as its last argument. If there are multiple
outputs, they all must appear as separate arguments.

This method cuts processing time by half!

### Per column

What happens when you pass `per_column=True` to apply each parameter combination per column?
Internally, [IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func) 
splits any input, in-place output, and parameter array per column, passing one element from each to `apply_func` 
at a time. However, the same splitting cannot be done for `cache_func`, because you would
then get 1) a list of input arrays instead of a single array (which would cause an error if the caching 
function was Numba-compiled, since Numba does not allow the same argument with two different types),
and 2) each input array in the list could be different, so maintaining a single caching dictionary with 
parameter combinations as keys would not be sufficient.

To handle this edge case, VBT passes input and in-place output arrays in their regular shape 
(not split), and also provides a `per_column` argument set to True, so `cache_func` knows
that each parameter corresponds to only one column in the input. In the caching function, you can 
use this flag to decide how to proceed. Usually, you simply disable caching and perform all calculations 
directly in the apply function.

```pycon
>>> def cache_func(ts, w1, w2, per_column=False):
...     if per_column:
...         return None
...     cache_dict = dict()
...     for w in w1 + w2:
...         if w not in cache_dict:
...             cache_dict[w] = roll_mean_expensive_nb(ts, w)
...     return cache_dict

>>> def apply_func(ts, w1, w2, cache_dict=None):  # (1)!
...     if cache_dict is None:
...         roll_mean1 = roll_mean_expensive_nb(ts, w1)
...         roll_mean2 = roll_mean_expensive_nb(ts, w2)
...     else:
...         roll_mean1 = cache_dict[w1]
...         roll_mean2 = cache_dict[w2]
...     return (roll_mean2 - roll_mean1) / roll_mean1
...     

>>> RelMADist = vbt.IF(
...     class_name="RelMADist",
...     input_names=['ts'],
...     param_names=['w1', 'w2'],
...     output_names=['out'],
... ).with_apply_func(apply_func, cache_func=cache_func)

>>> RelMADist.run(ts2, 2, 3).out
relmadist_w1                   2
relmadist_w2                   3
                     a         b
2020-01-01         NaN       NaN
2020-01-02         NaN       NaN
2020-01-03   -0.200000  0.333333
2020-01-04   -0.066667  0.111111
2020-01-05    0.333333 -0.200000
2020-01-06    0.111111 -0.066667
2020-01-07   -0.200000  0.333333

>>> RelMADist.run(ts2, [2, 2], [3, 4], per_column=True).out
relmadist_w1                   2
relmadist_w2         3         4
                     a         b
2020-01-01         NaN       NaN
2020-01-02         NaN       NaN
2020-01-03   -0.200000       NaN
2020-01-04   -0.066667  0.333333
2020-01-05    0.333333 -0.200000
2020-01-06    0.111111 -0.200000
2020-01-07   -0.200000  0.333333
```

1. Make cache optional.

This design is even better than the previous one because caching is now optional,
and any other function can call `apply_func` without needing to handle caching.
This approach also works with Numba.

### Reusing cache

Similar to raw outputs, you can force [IndicatorBase.run_pipeline](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorBase.run_pipeline)
and `custom_func` to return the cache, allowing you to reuse it in other calculations or even indicators. 
The clear advantage of this method is that you are not limited to a fixed set of parameter combinations, 
but can instead use the actual parameter values, providing more control over performance management.

```pycon
>>> cache = RelMADist.run(
...     ts2, 
...     w1=2, 
...     w2=np.arange(2, 1000), 
...     return_cache=True)

>>> %timeit RelMADist.run( \
...     ts2, \
...     w1=np.arange(2, 1000), \
...     w2=np.arange(2, 1000), \
...     use_cache=cache)
7.7 ms ± 153 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

## Stacking

Like regular functions, indicators can depend on each other. To build a stacked
indicator, the first step is to merge their inputs and parameters. Consider the classic
moving average crossover, where we want to use the TA-Lib `SMA` indicator twice: once for
the fast moving average and once for the slow moving average. By checking the arguments accepted by the 
indicator's `run` method, we see that it takes a time series `close` and a parameter `timeperiod`.
Since both moving averages use the same time series, our only input is `close`.
However, the parameter `timeperiod` should be different for each moving average, so we need to define two
parameters: `timeperiod1` and `timeperiod2` (feel free to use any other names).

```pycon
>>> vbt.phelp(vbt.talib('SMA').run)
SMA.run(
    close,
    timeperiod=Default(value=30),
    short_name='sma',
    hide_params=None,
    hide_default=True,
    **kwargs
):
    Run `SMA` indicator.
    
    * Inputs: `close`
    * Parameters: `timeperiod`
    * Outputs: `real`
    
    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.
    
    Other keyword arguments are passed to `SMA.run_pipeline`.

>>> def apply_func(close, timeperiod1, timeperiod2):
...     fast_ma = vbt.talib('SMA').run(close, timeperiod1)
...     slow_ma = vbt.talib('SMA').run(close, timeperiod2)
...     entries = fast_ma.real_crossed_above(slow_ma)
...     exits = fast_ma.real_crossed_below(slow_ma)
...     return (fast_ma.real, slow_ma.real, entries, exits)

>>> MACrossover = vbt.IF(
...     class_name="CrossSig",
...     input_names=['close'],
...     param_names=['timeperiod1', 'timeperiod2'],
...     output_names=['fast_ma', 'slow_ma', 'entries', 'exits'],
... ).with_apply_func(apply_func)

>>> MACrossover.run(ts2, 2, 3).entries
crosssig_timeperiod1             2
crosssig_timeperiod2             3
                          a      b
2020-01-01            False  False
2020-01-02            False  False
2020-01-03            False  False
2020-01-04            False  False
2020-01-05            False   True
2020-01-06            False  False
2020-01-07             True  False
```

This implementation does have one drawback: it needlessly creates two indicator instances
and repeatedly converts between NumPy arrays and Pandas objects. An ideal implementation would
use only NumPy and Numba. Fortunately, any indicator constructed by
[IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory) 
supports the `return_raw` argument, which allows you to access the actual NumPy array(s)
returned by the calculation function.

```pycon
>>> def sma(close, timeperiod):
...     return vbt.talib('SMA').run(close, timeperiod, return_raw=True)[0][0]

>>> def apply_func(close, timeperiod1, timeperiod2):
...     fast_ma = sma(close, timeperiod1)
...     slow_ma = sma(close, timeperiod2)
...     entries = vbt.nb.crossed_above_nb(fast_ma, slow_ma)
...     exits = vbt.nb.crossed_above_nb(slow_ma, fast_ma)
...     return (fast_ma, slow_ma, entries, exits)
```

Looking for another approach? Any indicator class created by 
[IndicatorFactory.with_custom_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_custom_func) 
has a `custom_func` attribute to access the custom function. Similarly, any indicator class 
created by [IndicatorFactory.with_apply_func](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory.with_apply_func)
has an `apply_func` attribute to access the apply function. This lets you call
an indicator's `custom_func` from your own `custom_func` and its `apply_func` from 
your own `apply_func`. Note that the `apply_func` of all parsed indicators is created dynamically 
with `pass_packed` set to True, so it accepts arguments in the packed form:

```pycon
>>> vbt.phelp(vbt.talib('SMA').apply_func)
apply_func(
    input_tuple,
    in_output_tuple,
    param_tuple,
    **_kwargs
)

>>> def sma(close, timeperiod):
...     return vbt.talib('SMA').apply_func((close,), (), (timeperiod,))
```

This approach is as fast as it gets!

[:material-language-python: Python code](https://vectorbt.pro/pvt_6d1b3986/assets/jupytext/documentation/indicators/development.py.txt){ .md-button target="blank_" }