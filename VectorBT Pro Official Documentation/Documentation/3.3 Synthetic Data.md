---
title: Synthetic
description: Documentation on generating synthetic data in VectorBT PRO
icon: material/creation
---

# :material-creation: Synthetic

Synthetic data refers to data that could have been generated by financial markets but was not. Synthetic
price and return data help address the financial small data problem and are useful for various purposes,
including testing new investment strategies and supporting data-hungry ML models. They also enable you
to identify behavioral differences and outliers between real and simulated markets. For example, if your
model performs well on a subset of real-world data, you can test it against synthetic data to check
whether you have unintentionally introduced look-ahead bias or other significant weaknesses into the
model.

To facilitate the generation of synthetic data, VBT provides the class
[SyntheticData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/synthetic/#vectorbtpro.data.custom.synthetic.SyntheticData). This class
takes a start date, end date, and frequency, then builds a datetime-like Pandas Index. Next, it calls the
abstract class method [SyntheticData.generate_key](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/synthetic/#vectorbtpro.data.custom.synthetic.SyntheticData.generate_key),
which takes the key and the index, generates new data, and returns a Series or DataFrame ready to be
used by [Data](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/#vectorbtpro.data.base.Data). Here, the key is either a feature or a symbol,
depending on the data orientation set by the user. You must override this method and implement your own
data generation logic.

!!! note
    If your logic depends on the data orientation (that is, whether features or symbols should be generated),
    you should be more specific and override [SyntheticData.generate_symbol](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/synthetic/#vectorbtpro.data.custom.synthetic.SyntheticData.generate_symbol)
    and/or [SyntheticData.generate_feature](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/synthetic/#vectorbtpro.data.custom.synthetic.SyntheticData.generate_feature).

There are two preset classes: [RandomData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/random/#vectorbtpro.data.custom.random.RandomData),
which uses cumulative normally-distributed returns, and [GBMData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/gbm/#vectorbtpro.data.custom.gbm.GBMData),
which utilizes the [Geometric Brownian Motion](https://en.wikipedia.org/wiki/Geometric_Brownian_motion).
Both generators are basic but are quite useful for testing models. However, one limitation is that real
asset prices often make dramatic moves in response to new information. To address this, we will create a
data generator based on the [Levy alpha-stable distribution](https://en.wikipedia.org/wiki/Stable_distribution)!

```pycon
>>> from vectorbtpro import *  # (1)!
>>> from scipy.stats import levy_stable

>>> def geometric_levy_price(alpha, beta, drift, vol, shape):  # (2)!
...     _rvs = levy_stable.rvs(alpha, beta,loc=0, scale=1, size=shape)
...     _rvs_sum = np.cumsum(_rvs, axis=0)
...     return np.exp(vol * _rvs_sum + (drift - 0.5 * vol ** 2))

>>> class LevyData(vbt.SyntheticData):  # (3)!
...
...     _settings_path = dict(custom="data.custom.levy")  # (4)!
...
...     @classmethod
...     def generate_key(
...         cls, 
...         key, 
...         index, 
...         columns, 
...         start_value=None,  # (5)!
...         alpha=None, 
...         beta=None, 
...         drift=None, 
...         vol=None, 
...         seed=None,
...         **kwargs
...     ):
...         start_value = cls.resolve_custom_setting(start_value, "start_value")  # (6)!
...         alpha = cls.resolve_custom_setting(alpha, "alpha")
...         beta = cls.resolve_custom_setting(beta, "beta")
...         drift = cls.resolve_custom_setting(drift, "drift")
...         vol = cls.resolve_custom_setting(vol, "vol")
...         seed = cls.resolve_custom_setting(seed, "seed")
...         if seed is not None:
...             np.random.seed(seed)
...
...         shape = (len(index), len(columns))
...         out = geometric_levy_price(alpha, beta, drift, vol, shape)
...         out = start_value * out
...         return pd.DataFrame(out, index=index, columns=columns)

>>> LevyData.set_custom_settings(  # (7)!
...     populate_=True,
...     start_value=100., 
...     alpha=1.68, 
...     beta=0.01, 
...     drift=0.0, 
...     vol=0.01, 
...     seed=None
... )
```

1. Imports `np`, `pd`, `njit`, and `vbt`.
2. Generation function. See [Asset price mimicry](https://medium.com/codex/generating-synthetic-price-data-2dd1e82fe5cf).
3. Subclass [SyntheticData](https://vectorbt.pro/pvt_6d1b3986/api/data/custom/synthetic/#vectorbtpro.data.custom.synthetic.SyntheticData).
4. Specify the path to global settings for this class and assign it a new identifier "custom".
There is one more identifier already registered: "base", which points to general settings.
5. Set most arguments to None to pull their default values from the global settings. You can also hard-code
the values here if you decide not to use global settings.
6. Access the global settings and replace None arguments with their default values.
7. Populate the global settings for this class.

Now, let's try it out by generating and plotting the close price for several symbols:

```pycon
>>> levy_data = LevyData.pull(
...     "Close",
...     keys_are_features=True,
...     columns=pd.Index(["BTC/USD", "ETH/USD", "XRP/USD"], name="symbol"),
...     start="2020-01-01 UTC",
...     end="2021-01-01 UTC",
...     seed=42)
>>> levy_data.get()
symbol                        BTC/USD     ETH/USD     XRP/USD
2020-01-01 00:00:00+00:00   99.218626  101.893255  100.371131
2020-01-02 00:00:00+00:00  100.062835   99.537102   97.857226
2020-01-03 00:00:00+00:00   95.321467  100.474547   98.246993
2020-01-04 00:00:00+00:00   96.493680   96.455981   99.797874
2020-01-05 00:00:00+00:00   98.489931   95.658733   98.892301
...                               ...         ...         ...
2020-12-27 00:00:00+00:00  189.477849   91.730109   55.055316
2020-12-28 00:00:00+00:00  190.620767   89.452822   59.555616
2020-12-29 00:00:00+00:00  187.641089   92.164802   60.034154
2020-12-30 00:00:00+00:00  188.287168   92.245270   59.188719
2020-12-31 00:00:00+00:00  185.500114   91.701142   58.443060

[366 rows x 3 columns]

>>> levy_data.get().vbt.plot().show()
```

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/data/synthetic_levy.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/data/synthetic_levy.dark.svg#only-dark){: .iimg loading=lazy }

Great job! We have built our own data generator that simulates sudden large price changes.

[:material-language-python: Python code](https://vectorbt.pro/pvt_6d1b3986/assets/jupytext/documentation/data/synthetic.py.txt){ .md-button target="blank_" }