---
title: Analysis
description: Documentation on analyzing indicators in VectorBT PRO
icon: material/chart-timeline-variant-shimmer
---

# :material-chart-timeline-variant-shimmer: Analysis

To analyze an indicator, use the indicator instance returned by the `run` method.

## Helper methods

Whenever you create an instance of [IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory),
it builds and sets up an indicator class. During this process, the factory attaches many useful
attributes to the class. For example, for each item in `input_names`, `in_output_names`, `output_names`,
and `lazy_outputs`, it creates and attaches a set of comparison and combination methods.
The properties of any of these attributes can be controlled using the `attr_settings` dictionary.

Let's modify the `CrossSig` class created earlier by combining entries and exits into a single signal
array. We will also return an enumerated array that indicates the signal type. Additionally,
we will specify the data type of each array in the `attr_settings` dictionary:

```pycon
>>> from vectorbtpro import *

>>> SignalType = namedtuple('SigType', ['Entry', 'Exit'])(0, 1)  # (1)!

>>> def apply_func(ts, fastw, sloww, minp=None):
...     fast_ma = vbt.nb.rolling_mean_nb(ts, fastw, minp=minp)
...     slow_ma = vbt.nb.rolling_mean_nb(ts, sloww, minp=minp)
...     entries = vbt.nb.crossed_above_nb(fast_ma, slow_ma)
...     exits = vbt.nb.crossed_above_nb(slow_ma, fast_ma)
...     signals = entries | exits
...     signal_type = np.full(ts.shape, -1, dtype=int_)  # (2)!
...     signal_type[entries] = SignalType.Entry
...     signal_type[exits] = SignalType.Exit
...     return (fast_ma, slow_ma, signals, signal_type)

>>> CrossSig = vbt.IF(
...     class_name="CrossSig",
...     input_names=['ts'],
...     param_names=['fastw', 'sloww'],
...     output_names=['fast_ma', 'slow_ma', 'signals', 'signal_type'],
...     attr_settings=dict(
...         fast_ma=dict(dtype=float_),
...         slow_ma=dict(dtype=float_),
...         signals=dict(dtype=np.bool_),
...         signal_type=dict(dtype=SignalType),
...     )
... ).with_apply_func(apply_func)

>>> def generate_index(n):
...     return vbt.date_range("2020-01-01", periods=n)

>>> ts = pd.DataFrame({
...     'a': [1, 2, 3, 2, 1, 2, 3],
...     'b': [3, 2, 1, 2, 3, 2, 1]
... }, index=generate_index(7))
>>> cross_sig = CrossSig.run(ts, 2, 3)
```

1. Enum values in VBT usually start at 0 and increase incrementally.
2. In VBT, a missing value is typically represented as `-1`.

We can explore the helper methods that were attached using Python's `dir` command:

```pycon
>>> dir(cross_sig)
...
'fast_ma',
'fast_ma_above',
'fast_ma_below',
'fast_ma_crossed_above',
'fast_ma_crossed_below',
'fast_ma_equal',
'fast_ma_stats',
...
'signal_type',
'signal_type_readable',
'signal_type_stats',
...
'signals',
'signals_and',
'signals_or',
'signals_stats',
'signals_xor',
...
'slow_ma',
'slow_ma_above',
'slow_ma_below',
'slow_ma_crossed_above',
'slow_ma_crossed_below',
'slow_ma_equal',
'slow_ma_stats',
...
'ts',
'ts_above',
'ts_below',
'ts_crossed_above',
'ts_crossed_below',
'ts_equal',
'ts_stats',
```

One helper method that appears for each array is `stats`, which calls 
[StatsBuilderMixin.stats](https://vectorbt.pro/pvt_6d1b3986/api/generic/stats_builder/#vectorbtpro.generic.stats_builder.StatsBuilderMixin.stats)
on the accessor that matches the data type of the array:

```pycon
>>> cross_sig.fast_ma_stats(column=(2, 3, 'a'))  # (1)!
Start        2020-01-01 00:00:00
End          2020-01-07 00:00:00
Period           7 days 00:00:00
Count                          6
Mean                         2.0
Std                     0.547723
Min                          1.5
Median                       2.0
Max                          2.5
Min Index    2020-01-02 00:00:00
Max Index    2020-01-03 00:00:00
Name: (2, 3, a), dtype: object
```

1. Uses [GenericAccessor.stats](https://vectorbt.pro/pvt_6d1b3986/api/generic/accessors/#vectorbtpro.generic.accessors.GenericAccessor.stats).

You can also perform the same operation manually:

```pycon
>>> cross_sig.fast_ma.vbt.stats(column=(2, 3, 'a'))
```

### Numeric

The factory generated the comparison methods `above`, `below`, and `equal` for the numeric arrays.
Each of these methods is based on [combine_objs](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.combine_objs),
which in turn builds on [BaseAccessor.combine](https://vectorbt.pro/pvt_6d1b3986/api/base/accessors/#vectorbtpro.base.accessors.BaseAccessor.combine).
All operations are performed strictly with NumPy. Another benefit is that VBT's own broadcasting
is used, allowing you to combine arrays with any array-like object as long as their shapes can be
broadcast together. You can also compare with multiple objects at once by passing them as a tuple or
list.

Let's return True when the fast moving average is above a range of thresholds:

```pycon
>>> cross_sig.fast_ma_above([2, 3])
crosssig_fast_ma_above             2             3
crosssig_fastw                     2             2
crosssig_sloww                     3             3
                            a      b      a      b
2020-01-01              False  False  False  False
2020-01-02              False   True  False  False
2020-01-03               True  False  False  False
2020-01-04               True  False  False  False
2020-01-05              False   True  False  False
2020-01-06              False   True  False  False
2020-01-07               True  False  False  False
```

Or, manually:

```pycon
>>> cross_sig.fast_ma.vbt > vbt.Param([2, 3], name='crosssig_fast_ma_above')
```

Additionally, the factory attached the methods `crossed_above` and `crossed_below`.
These are based on [GenericAccessor.crossed_above](https://vectorbt.pro/pvt_6d1b3986/api/generic/accessors/#vectorbtpro.generic.accessors.GenericAccessor.crossed_above)
and [GenericAccessor.crossed_below](https://vectorbt.pro/pvt_6d1b3986/api/generic/accessors/#vectorbtpro.generic.accessors.GenericAccessor.crossed_below)
respectively.

```pycon
>>> cross_sig.fast_ma_crossed_above(cross_sig.slow_ma)
crosssig_fastw             2
crosssig_sloww             3
                    a      b
2020-01-01      False  False
2020-01-02      False  False
2020-01-03      False  False
2020-01-04      False  False
2020-01-05      False   True
2020-01-06      False  False
2020-01-07       True  False
```

Or, manually:

```pycon
>>> cross_sig.fast_ma.vbt.crossed_above(cross_sig.slow_ma)
```

### Boolean

The factory generated the comparison methods `and`, `or`, and `xor` for the boolean arrays.
Similar to those generated for numeric arrays, these are also based on
[combine_objs](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.combine_objs):

```pycon
>>> other_signals = pd.Series([False, False, False, False, True, False, False])
>>> cross_sig.signals_and(other_signals)
crosssig_fastw             2
crosssig_sloww             3
                    a      b
2020-01-01      False  False
2020-01-02      False  False
2020-01-03      False  False
2020-01-04      False  False
2020-01-05       True   True
2020-01-06      False  False
2020-01-07      False  False
```

Or, manually:

```pycon
>>> cross_sig.signals.vbt & other_signals
```

### Enumerated

Enumerated (or categorical) arrays, such as our `signal_type`, contain integer data that can be mapped
to specific categories using a named tuple or another enum. Unlike numeric and boolean arrays,
comparing them with other arrays is not meaningful. As a result, there is only one attached method,
`readable`, which displays the array in a human-readable format:

```pycon
>>> cross_sig.signal_type_readable
crosssig_fastw             2
crosssig_sloww             3
                    a      b
2020-01-01       None   None
2020-01-02       None   None
2020-01-03       None   None
2020-01-04       None   None
2020-01-05       Exit  Entry
2020-01-06       None   None
2020-01-07      Entry   Exit
```

!!! hint
    In VBT, if `-1` is not included in the enum, it automatically indicates a missing value and
    is replaced by `None`.

Or, manually:

```pycon
>>> cross_sig.signal_type.vbt(mapping=SignalType).apply_mapping()
```

## Indexing

Each indicator class inherits from [Analyzable](https://vectorbt.pro/pvt_6d1b3986/documentation/building-blocks/#analyzing), allowing you
to use Pandas indexing on the indicator instance to select rows and columns across all Pandas objects.
Supported operations include `iloc`, `loc`, `xs`, and `__getitem__`.

```pycon
>>> cross_sig = CrossSig.run(ts, [2, 3], [3, 4], param_product=True)

>>> cross_sig.loc["2020-01-03":, (2, 3, 'a')]  # (1)!
<vectorbtpro.indicators.factory.CrossSig at 0x7fcaf8e2f5c0>

>>> cross_sig.loc["2020-01-03":, (2, 3, 'a')].signals
2020-01-03    False
2020-01-04    False
2020-01-05     True
2020-01-06    False
2020-01-07     True
Name: (2, 3, a), dtype: bool
```

1. Using a single Pandas indexing operation.

Additionally, [IndicatorFactory](https://vectorbt.pro/pvt_6d1b3986/api/indicators/factory/#vectorbtpro.indicators.factory.IndicatorFactory)
uses the class factory function [build_param_indexer](https://vectorbt.pro/pvt_6d1b3986/api/base/indexing/#vectorbtpro.base.indexing.build_param_indexer)
to generate an indexing class that enables Pandas-style indexing on each parameter.
Since the indicator class inherits from this indexing class, you can use `*param_name*_loc`
to select one or more parameter values.

```pycon
>>> cross_sig.fastw_loc[2].sloww_loc[3]['a']  # (1)!
<vectorbtpro.indicators.factory.CrossSig at 0x7fcac80742b0>

>>> cross_sig.fastw_loc[2].sloww_loc[3]['a'].signals
2020-01-01    False
2020-01-02    False
2020-01-03    False
2020-01-04    False
2020-01-05     True
2020-01-06    False
2020-01-07     True
Name: a, dtype: bool
```

1. Using two parameter and one Pandas indexing operation. Each of these operations returns
a separate instance of `CrossSig`.

All of this allows you to access rows and columns by labels, integer positions, and parameters,
offering complete flexibility :man_cartwheeling:

## Stats and plots

As with any [Analyzable](https://vectorbt.pro/pvt_6d1b3986/api/generic/analyzable/#vectorbtpro.generic.analyzable.Analyzable) instance,
you can compute and plot various properties of the input and output data stored in the instance.

Metrics can be set in two ways: by passing them through the `metrics` argument, or by
subclassing the indicator class. The same applies to the `stats_defaults` argument, which
can be specified as either a dictionary or a function, and defines the default settings for
[StatsBuilderMixin.stats](https://vectorbt.pro/pvt_6d1b3986/api/generic/stats_builder/#vectorbtpro.generic.stats_builder.StatsBuilderMixin.stats).
Subplots can be defined similarly to metrics, but are set using the `subplots` and
`plots_defaults` arguments, and invoked through [PlotsBuilderMixin.plots](https://vectorbt.pro/pvt_6d1b3986/api/generic/plots_builder/#vectorbtpro.generic.plots_builder.PlotsBuilderMixin.plots).

Let's define some metrics and subplots for `CrossSig`:

```pycon
>>> metrics = dict(
...     start=dict(  # (1)!
...         title='Start',
...         calc_func=lambda self: self.wrapper.index[0],
...         agg_func=None
...     ),
...     end=dict(  # (2)!
...         title='End',
...         calc_func=lambda self: self.wrapper.index[-1],
...         agg_func=None
...     ),
...     period=dict(  # (3)!
...         title='Period',
...         calc_func=lambda self: len(self.wrapper.index),
...         apply_to_timedelta=True,
...         agg_func=None
...     ),
...     fast_stats=dict(  # (4)!
...         title="Fast Stats",
...         calc_func=lambda self:
...         self.fast_ma.describe()\
...         .loc[['count', 'mean', 'std', 'min', 'max']]\
...         .vbt.to_dict(orient='index_series')
...     ),
...     slow_stats=dict(
...         title="Slow Stats",
...         calc_func=lambda self:
...         self.slow_ma.describe()\
...         .loc[['count', 'mean', 'std', 'min', 'max']]\
...         .vbt.to_dict(orient='index_series')
...     ),
...     num_entries=dict(  # (5)!
...         title="Entries",
...         calc_func=lambda self:
...         np.sum(self.signal_type == SignalType.Entry)
...     ),
...     num_exits=dict(
...         title="Exits",
...         calc_func=lambda self:
...         np.sum(self.signal_type == SignalType.Exit)
...     )
... )

>>> def plot_mas(self, column=None, add_trace_kwargs=None, fig=None):  # (6)!
...     ts = self.select_col_from_obj(self.ts, column).rename('TS')  # (7)!
...     fast_ma = self.select_col_from_obj(self.fast_ma, column).rename('Fast MA')
...     slow_ma = self.select_col_from_obj(self.slow_ma, column).rename('Slow MA')
...     ts.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...     fast_ma.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)  # (8)!
...     slow_ma.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)

>>> def plot_signals(self, column=None, add_trace_kwargs=None, fig=None):
...     signal_type = self.select_col_from_obj(self.signal_type, column)
...     entries = (signal_type == SignalType.Entry).rename('Entries')
...     exits = (signal_type == SignalType.Exit).rename('Exits')
...     entries.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...     exits.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)

>>> subplots = dict(
...     mas=dict(
...         title="Moving averages",
...         plot_func=plot_mas
...     ),
...     signals=dict(
...         title="Signals",
...         plot_func=plot_signals
...     )
... )

>>> CrossSig = vbt.IF(
...     class_name="CrossSig",
...     input_names=['ts'],
...     param_names=['fastw', 'sloww'],
...     output_names=['fast_ma', 'slow_ma', 'signals', 'signal_type'],
...     attr_settings=dict(
...         fast_ma=dict(dtype=float_),
...         slow_ma=dict(dtype=float_),
...         signals=dict(dtype=np.bool_),
...         signal_type=dict(dtype=SignalType),
...     ),
...     metrics=metrics,  # (9)!
...     subplots=subplots
... ).with_apply_func(apply_func)

>>> cross_sig = CrossSig.run(ts, [2, 3], 4)
```

1. Index of the first data point.
2. Index of the last data point.
3. The number of data points multiplied by the index frequency.
4. Takes `fast_ma`, generates descriptive statistics using Pandas, and converts them to a dictionary
with Series (per statistic) using [BaseAccessor.to_dict](https://vectorbt.pro/pvt_6d1b3986/api/base/accessors/#vectorbtpro.base.accessors.BaseAccessor.to_dict).
The `dict` type tells VBT to make multiple metrics from one.
5. Number of entry signals.
6. [PlotsBuilderMixin.plots](https://vectorbt.pro/pvt_6d1b3986/api/generic/plots_builder/#vectorbtpro.generic.plots_builder.PlotsBuilderMixin.plots)
can automatically recognize the arguments your plotting function takes and pass the needed information.
For example, it detects `self` and passes the indicator instance.
7. Since we are plotting multiple time series, we cannot plot multiple columns at once, so we must
select the provided column from each time series using [Wrapping.select_col_from_obj](https://vectorbt.pro/pvt_6d1b3986/api/base/wrapping/#vectorbtpro.base.wrapping.Wrapping.select_col_from_obj).
8. `fig` is the figure and `add_trace_kwargs` contains subplot settings for plotting this time series.
Note that the function does not return anything; the figure is modified in place.
9. Metric and subplot dictionaries are passed to the constructor.

Calculate the metrics:

```pycon
>>> cross_sig.stats(column=(2, 4, 'a'))
Start                2020-01-01 00:00:00
End                  2020-01-07 00:00:00
Period                   7 days 00:00:00
Fast Stats: count                    6.0
Fast Stats: mean                     2.0
Fast Stats: std                 0.547723
Fast Stats: min                      1.5
Fast Stats: max                      2.5
Slow Stats: count                    4.0
Slow Stats: mean                     2.0
Slow Stats: std                      0.0
Slow Stats: min                      2.0
Slow Stats: max                      2.0
Entries                                1
Exits                                  1
Name: (2, 4, a), dtype: object
```

Plot the subplots:

```pycon
>>> cross_sig.plots(column=(2, 4, 'a')).show()
```

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/plots.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/plots.dark.svg#only-dark){: .iimg loading=lazy }

We have created a smart indicator, yay! :partying_face:

## Extending

Indicator classes can be extended and modified just like regular Python classes, by subclassing.
Let's turn the newly created `plot_mas` and `plot_signals` functions into methods of the indicator
class, so we can plot each graph separately. We will also redefine the `subplots`
configuration to reflect this change:

```pycon
>>> class SmartCrossSig(CrossSig):
...     def plot_mas(self, column=None, add_trace_kwargs=None, fig=None):
...         ts = self.select_col_from_obj(self.ts, column).rename('TS')
...         fast_ma = self.select_col_from_obj(self.fast_ma, column).rename('Fast MA')
...         slow_ma = self.select_col_from_obj(self.slow_ma, column).rename('Slow MA')
...         fig = ts.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...         fast_ma.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...         slow_ma.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...         return fig  # (1)!
...
...     def plot_signals(self, column=None, add_trace_kwargs=None, fig=None):
...         signal_type = self.select_col_from_obj(self.signal_type, column)
...         entries = (signal_type == SignalType.Entry).rename('Entries')
...         exits = (signal_type == SignalType.Exit).rename('Exits')
...         fig = entries.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...         exits.vbt.plot(add_trace_kwargs=add_trace_kwargs, fig=fig)
...         return fig
...
...     subplots = vbt.HybridConfig(  # (2)!
...         mas=dict(
...             title="Moving averages",
...             plot_func='plot_mas'  # (3)!
...         ),
...         signals=dict(
...             title="Signals",
...             plot_func='plot_signals'
...         )
...     )

>>> smart_cross_sig = SmartCrossSig.run(ts, [2, 3], 4)
>>> smart_cross_sig.plot_signals(column=(2, 4, 'a')).show()
```

1. Since both plotting functions can now be called by the user, we need to return the figure
if it was not provided.
2. When setting `metrics` and `subplots` manually, we need to use [Config](https://vectorbt.pro/pvt_6d1b3986/api/utils/config/#vectorbtpro.utils.config.Config)
instead of `dict`.
3. Since both functions are now class attributes, we can specify them as strings to take advantage of
VBT's [attribute resolution](https://vectorbt.pro/pvt_6d1b3986/documentation/building-blocks/#attribute-resolution).

![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/plot_signals.light.svg#only-light){: .iimg loading=lazy }
![](https://vectorbt.pro/pvt_6d1b3986/assets/images/documentation/indicators/plot_signals.dark.svg#only-dark){: .iimg loading=lazy }

[:material-language-python: Python code](https://vectorbt.pro/pvt_6d1b3986/assets/jupytext/documentation/indicators/analysis.py.txt){ .md-button target="blank_" }